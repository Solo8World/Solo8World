<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lee Blog</title>
  
  <subtitle>Less is more.  enmm... except hair</subtitle>
  <link href="leeblog.icu/atom.xml" rel="self"/>
  
  <link href="leeblog.icu/"/>
  <updated>2023-01-31T15:21:56.412Z</updated>
  <id>leeblog.icu/</id>
  
  <author>
    <name>Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PG实践踩坑记录</title>
    <link href="leeblog.icu/2023/01/31/"/>
    <id>leeblog.icu/2023/01/31/</id>
    <published>2023-01-31T09:57:30.000Z</published>
    <updated>2023-01-31T15:21:56.412Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录一下找bug过程中与思维惯性相悖的千奇百怪,不间断更新</p></blockquote><hr><h3 id="ID自增序列"><a href="#ID自增序列" class="headerlink" title="ID自增序列"></a>ID自增序列</h3><ul><li><p>你有一张id自增的表，id自增至99。</p></li><li><p>A同事执行了指定id值的插入语句 <code>INSERT INTO XXX （id，value） VALUES（100，&#39;李大本事&#39;）；</code></p></li><li><p>B同事再执行不指定id值的插入语句 <code>INSERT INTO XXX （value） VALUES（&#39;李白&#39;）；</code></p></li><li><p>此时报错<code>id already exists</code></p><p>请执行以下sql后再次执行插入：</p></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> setval(<span class="string">&#x27;bi_data_sale_order_detail_id_seq&#x27;</span>, </span><br><span class="line">              (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(<span class="keyword">id</span>) <span class="keyword">FROM</span> bi_data_sale_order_detail));</span><br></pre></td></tr></table></figure><hr><h3 id="数值的类型与保留位数"><a href="#数值的类型与保留位数" class="headerlink" title="数值的类型与保留位数"></a>数值的类型与保留位数</h3><p>  根据产品需求，你需要一个3与13的百分比比值，要求结果（比值）保留两位小数。</p><p>  <code>select round(3/13,4)*100；</code>执行这个sql你只会得到0；</p><p>  <code>select round(3::numeric/13::numeric,4)*100；</code>执行这个sql，你大概率会得到一个肉眼看起来是23.08的数字,直到你发现程序bug前这不会有什么问题。</p><p>  <code>select ((round(3::numeric/13::numeric,4))*100)::varchar；</code>再次执行这个sql，你才能看到这个结果的真正面目—他其实是‘23.0800’；</p><p>  最终，你只能这么干，  <code>select round(round(3::numeric/13::numeric,4)*100,2);</code></p><hr><h3 id="DataGrip与array-agg与时区"><a href="#DataGrip与array-agg与时区" class="headerlink" title="DataGrip与array_agg与时区"></a>DataGrip与array_agg与时区</h3><p>这个坑只在DataGrip有复现，指定数据库连接参数-Duser.timezone=PRC，执行以下sql。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="keyword">test</span> <span class="keyword">as</span> (<span class="keyword">select</span>  <span class="keyword">now</span>() <span class="keyword">as</span> d)</span><br><span class="line"><span class="keyword">select</span> array_agg(d),d <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">group</span> <span class="keyword">by</span> d;</span><br></pre></td></tr></table></figure><p>  会发现两个d值发生了时区不一致。</p><p>  只能转为varchar来规避该问题。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="keyword">test</span> <span class="keyword">as</span> (<span class="keyword">select</span>  <span class="keyword">now</span>() <span class="keyword">as</span> d)</span><br><span class="line"><span class="keyword">select</span> array_agg(d::<span class="built_in">varchar</span>),d <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">group</span> <span class="keyword">by</span> d;</span><br></pre></td></tr></table></figure><hr><h3 id="week的-date-part-与date-trunc"><a href="#week的-date-part-与date-trunc" class="headerlink" title="week的 date_part 与date_trunc"></a>week的 date_part 与date_trunc</h3><p>根据产品需求按周统计数据：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> date_part(<span class="string">&#x27;year&#x27;</span>::<span class="built_in">text</span>, order_date) <span class="keyword">AS</span> <span class="keyword">year</span>,</span><br><span class="line">       date_part(<span class="string">&#x27;week&#x27;</span>::<span class="built_in">text</span>, order_date) <span class="keyword">AS</span> <span class="keyword">week</span></span><br><span class="line"><span class="keyword">from</span> xxx</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> date_part(<span class="string">&#x27;year&#x27;</span>::<span class="built_in">text</span>, order_date) <span class="keyword">AS</span> <span class="keyword">year</span>, date_part(<span class="string">&#x27;week&#x27;</span>::<span class="built_in">text</span>, order_date) <span class="keyword">AS</span> <span class="keyword">week</span></span><br></pre></td></tr></table></figure><p>直到执行以下sql：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>   date_part(<span class="string">&#x27;year&#x27;</span>::<span class="built_in">text</span>,<span class="string">&#x27;2022-01-01&#x27;</span>::<span class="built_in">date</span>)                                       <span class="keyword">AS</span> <span class="keyword">year</span>,</span><br><span class="line">            date_part(<span class="string">&#x27;week&#x27;</span>::<span class="built_in">text</span>,<span class="string">&#x27;2022-01-01&#x27;</span>::<span class="built_in">date</span>)                                       <span class="keyword">AS</span> <span class="keyword">week</span></span><br></pre></td></tr></table></figure><p>应修改为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>   date_part(<span class="string">&#x27;year&#x27;</span>::<span class="built_in">text</span>, date_trunc(<span class="string">&#x27;week&#x27;</span>::<span class="built_in">text</span>,<span class="string">&#x27;2022-01-01&#x27;</span>::<span class="built_in">date</span>) )    <span class="keyword">AS</span> <span class="keyword">year</span>,</span><br><span class="line">            date_part(<span class="string">&#x27;week&#x27;</span>::<span class="built_in">text</span>,<span class="string">&#x27;2022-01-01&#x27;</span>::<span class="built_in">date</span>)                                           <span class="keyword">AS</span> <span class="keyword">week</span></span><br></pre></td></tr></table></figure><hr><h3 id="week的计算-与ISO8601标准"><a href="#week的计算-与ISO8601标准" class="headerlink" title="week的计算 与ISO8601标准"></a>week的计算 与ISO8601标准</h3><p>一直粗暴理解pg的周计算标准是以第一个周一来算第一周：</p><p>直到执行以下sql：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> date_part(<span class="string">&#x27;WEEK&#x27;</span>,<span class="string">&#x27;2020-01-01&#x27;</span>::<span class="built_in">date</span>);</span><br><span class="line"><span class="keyword">SELECT</span> date_part(<span class="string">&#x27;WEEK&#x27;</span>,<span class="string">&#x27;2022-01-01&#x27;</span>::<span class="built_in">date</span>);</span><br></pre></td></tr></table></figure><p>查阅相关资料后发现，周数计算是按照ISO8601标准来的：</p><p>ISO 8601中关于星期规定如下：<br>该年度的1月1日，如果是星期一，星期二，星期三，星期四，那么，1月1日所在的星期就是该年度的第一个星期。<br>该年度的1月1日，如果是星期五，星期六，星期日，那么1月1日所在的星期就是上一年的最后一个星期。<br>每个星期以星期一为开始，星期日为结束。</p><p><strong>本文作者</strong>：Lee<br/><strong>本文地址</strong>： <a href="leeblog.icu/2023/01/31/">leeblog.icu/2023/01/31/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC 4.0 BY-NC-SA</a> 许可协议。转载请注明出处！</p>]]></content>
    
    
    <summary type="html">记录一下找bug过程中与思维惯性相悖的千奇百怪,不间断更新</summary>
    
    
    
    <category term="技术" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="postgres" scheme="leeblog.icu/tags/postgres/"/>
    
  </entry>
  
  <entry>
    <title>关于一个单领域单轮对话任务型问答系统的调研与设计</title>
    <link href="leeblog.icu/2023/01/28/"/>
    <id>leeblog.icu/2023/01/28/</id>
    <published>2023-01-28T09:50:39.000Z</published>
    <updated>2023-01-28T10:18:04.500Z</updated>
    
    <content type="html"><![CDATA[<h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><p>   商业系统针对商业运营进行了多年深耕,形成了全方位的闭环运营,包括EAM系统(合同管理,租金结算),CDP系统(会员管理,积分结算),灵犀pos(收银系统),EMA系统(卡劵营销,储值卡),BI系统.以及深度接入客流识别系统.<br>   在商业领域做单领域的任务型问答系统,具有得天独厚的条件.且商业体运营人员在某些维度的数据查询场景,是零散化的,需要一个即时方便的,随用随走的数字化助理,来响应这些临时且零散的查询需求.</p><h3 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h3><blockquote><p>BPMC嵌入IM即时通讯系统、好友列表内置智能助理</p></blockquote><p>目前看是两个功能方向：</p><ul><li><p>一.支持智能问答商业相关的数据指标，如：查询销售、客流、坪效、会员注册数、卡劵核销量、租金等。<br>结果信息根据问题类型分别进行文本回复、图片回复、文件回复。</p></li><li><p>二.支持操作类任务(自动化工作流)：分两种，一种为后台自动执行，如：租金结算、店铺状态变更、会员批处理、员工离职处理（帐号禁用）。<br>另一种是针对敏感或复杂操作，将根据用户消息、分析用户目的，自动在portal页面打开相关系统并加载到目标菜单，让用户自行操作。</p></li><li><p>智能助理项目第一阶段将针对问答指标进行设计实现,如:</p><ul><li>Q: 优衣库今天的销售是多少?</li><li>Q: 今年全场客流有多少?</li><li>Q: 本月销售前三店铺是那些?</li></ul></li></ul><h3 id="整体实现流程"><a href="#整体实现流程" class="headerlink" title="整体实现流程"></a>整体实现流程</h3><p><code>IM系统内置助理帐号</code> -&gt; <code>助理帐号接收消息</code>-&gt; <code>触发文本分析</code> -&gt; <code>执行相关操作/查询</code> -&gt;<code>组装结果内容</code> -&gt; <code>回复消息</code><br><br/></p><h3 id="相关问答系统调研"><a href="#相关问答系统调研" class="headerlink" title="相关问答系统调研"></a>相关问答系统调研</h3><p><img src="https://s1.ax1x.com/2023/01/28/pSaCjfA.png" alt="dialogue"></p><p>目前主流问答系统分三种，一是检索式问答系统，二是生成式问答系统,三是任务型问答系统。</p><h5 id="检索式问答系统"><a href="#检索式问答系统" class="headerlink" title="检索式问答系统"></a>检索式问答系统</h5><p>机器人的回答是预先设置好的，在聊天时机器人使用规则引擎、模型匹配或机器学习生成好的模型从知识库中挑选一个最佳答案给用户，需要在机器人引擎后台中建立一个知识库。优点在于回答质量比较高，缺点在于需要预先准备的知识库足够完整。</p><ul><li>简单流程：Query的简单理解——从知识库检索召回——相似度排序<img src="https://s1.ax1x.com/2023/01/28/pSaPS6P.png" width="70%"></li></ul><br/><ul><li><p>类似系统</p><img src="https://s1.ax1x.com/2023/01/28/pSaCzlt.png" width="30%"></li></ul><hr><h5 id="生成式问答系统"><a href="#生成式问答系统" class="headerlink" title="生成式问答系统"></a>生成式问答系统</h5><p>生成式机器人不依赖于提前定义的回答，机器人接收到用户输入的自然语言后，将采用自然语言生成技术生成一段话作为应答。优点是可以涵盖任何话题，缺点是生成的句子质量可能存在问题，比如出现语法和语义问题。</p><ul><li>简单流程： Query的复杂理解（涵盖领域、意图）——对话管理（根据识别的领域进行知识模版/策略的构建）——自然语言生成（以文本形式将策略返还给用户）</li><li>类似系统有微软小冰,以及最近爆火的ChatGPT.<br><img src="https://s1.ax1x.com/2023/01/28/pSaPCm8.png" alt="img_4.png"></li></ul><hr><h5 id="任务型问答系统"><a href="#任务型问答系统" class="headerlink" title="任务型问答系统"></a>任务型问答系统</h5><p>任务型对话系统面向垂直领域，目的是使用尽可能少的对话轮数帮助用户完成预定任务或动作，例如预定机票、酒店和餐馆等.大多数任务型对话系统对话数据规模较小，难以通过大量数据进行模型 训练，前期需用手工制定的规则解决冷启动问题，这使得对话系统的构建变得昂贵和耗时.<br>目前工业界有两种实现方式，一种是基于规则的实现方式，另一种则是基于End-to-End的实现方式。<br>基于End-to-End的实现方式试图训练一个从用户端自然语言输入到机器端自然语言输出的整体映射关系，从而提高系统的灵活性与可拓展性，但该模型对数据的质量和数量要求非常高，并且存在不可解释性，因此，目前工业界大多采用基于规则的实现方式。<br><img src="https://s1.ax1x.com/2023/01/28/pSaPpOf.png" alt="任务型问答系统"></p><br/><ul><li><p>类似系统</p><img src="https://s1.ax1x.com/2023/01/28/pSaPAYj.png" width="60%"></li></ul><hr><h5 id="自然语言转sql方式："><a href="#自然语言转sql方式：" class="headerlink" title="自然语言转sql方式："></a>自然语言转sql方式：</h5><p>显然我们的需求绝不是生成式问答系统，也不完全是检索式问答系统。与我们后期计划实现的自动化操作的方向也不符,我们的产品需求其实属于任务型对话,但是任务型对话往往是多轮对话,针对一期需求,我们只需要简单的单轮对话即可,属于这么个流程:</p><p>Q: “优衣库今天的销售是多少”</p><p>提取关键词: “优衣库” “今天” “销售” </p><p>根据关键词生成并执行sql :  “select sum(order_amount) from sale_data where shop = ‘优衣库’ and order_date = now()::date”,</p><p>返回结果,end;</p><p>于是进一步去查了下自然语言转sql的现有方案:<code>Text to sql</code>。</p><p>从本任务涉及的数据来看，用户输入为自然语言问题，可利用的数据有数据库、SQL关键词，输出为SQL查询语句，<br>本质上是一个符合语法、有逻辑结构的序列。所以，sql的构成来自三部分：</p><ul><li>自然语言问题：结合数据库，一般可以直接抽取出sql中需要的表名，列名，条件表达式，条件值</li><li>数据库：结合自然语言问题，一般用于辅助识别sql中需要的表名，列名，条件表达式，条件值 </li><li>SQL关键词：作为sql查询语句的候选token，用于生成sql.<br>所有工作都在完成基于上述三部分数据来生成一个可在给定数据库中执行以获取正确结果的sql。</li></ul><p>根据SQL执行的复杂程度，可以将其分为简单SQL和复杂SQL。<br>简单SQL只涉及少数的SQL关键字和组成部分，典型特征是可以拆分为“SELECT”和“WHERE”两个片段。<br>简单SQL语句都可以抽象成如下的模板：</p><p><img src="https://s1.ax1x.com/2023/01/28/pSaPm60.png" alt="img_6.png"></p><ul><li>SELECT描述选择哪些列，并对这些列分别做什么操作，决定了最终选择的结果</li><li>WHERE描述选择的方法或者条件，决定这些列哪些单元格能被选择出来</li><li>AGG表示聚合函数，如求max，计数count，求min</li><li>COLUMN表示需要查询的目标列</li><li>WOP表示多个条件之间的关联规则“与/或”</li><li>三元组 [COLUMN, OP, VALUE] 构成了查询条件，分别代表条件列、条件操作符（&gt;,=,&lt;等）、条件值（从问题中抽取出的文本片段）</li><li>*表示目标列和查询条件不止一个！</li></ul><h3 id="调研结论"><a href="#调研结论" class="headerlink" title="调研结论"></a>调研结论</h3><p>本次调研主要对问答系统做了初步了解,对Text to sql的简单sql分析的实现思路做了学习,获取很多新思路,因为本需求实现为单领域单轮对话系统,尚属初步阶段,所以实现起来复杂度要尽可能的低,所以不考虑直接引入机器学习等成本较高的方案,基于以上调研,结合需求的具体场景,设计了以下方案来评估可行性.</p><h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>  本方案主要针对语言解析实现,在标准词库的基础上,补充领域词库,如店铺名称,业务名词,业态名称等,通过对用户语句进行分词,来进行领域匹配,如果是业务查询域,进行槽位补充,得到可执行sql,进行返回.</p><h4 id="整体流程图"><a href="#整体流程图" class="headerlink" title="整体流程图"></a>整体流程图</h4><p>在某些特定领域缺失判断时,可默认设置一个选项,比如:优衣库销售是多少? 缺失时间条件,可默认按照当日处理.(槽位补充)</p><p><img src="https://s1.ax1x.com/2023/01/28/pSaPKmT.png" alt="整体流程图"></p><h4 id="领域分析模块词库匹配关系示意图"><a href="#领域分析模块词库匹配关系示意图" class="headerlink" title="领域分析模块词库匹配关系示意图"></a>领域分析模块词库匹配关系示意图</h4><p>通过词库匹配关系,拿到一个sql所需要的元素,如查询目标表,查询字段,查询条件.<br><img src="https://s1.ax1x.com/2023/01/28/pSaPQ7F.png" alt="领域分析模块词库匹配关系示意图"></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>在动手做demo实验可行性.</p><h3 id="参考资料及引用"><a href="#参考资料及引用" class="headerlink" title="参考资料及引用:"></a>参考资料及引用:</h3><p><a href="http://cjc.ict.ac.cn/online/onlinepaper/zyy-2020925185056.pdf">任务型对话系统研究综述</a><br><a href="https://zhuanlan.zhihu.com/p/430369730">万字综述Text to SQL技术</a><br><a href="https://blog.51cto.com/u_15404184/5234836">NLP: 基于文本语义的智能问答系统</a>  </p><p><strong>本文作者</strong>：Lee<br/><strong>本文地址</strong>： <a href="leeblog.icu/2023/01/28/">leeblog.icu/2023/01/28/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC 4.0 BY-NC-SA</a> 许可协议。转载请注明出处！</p>]]></content>
    
    
    <summary type="html">商业体运营人员在某些维度的数据查询场景,是零散化的, 需要一个即时方便的,随用随走的数字化助理,来响应这些临时且零散的查询需求</summary>
    
    
    
    <category term="技术" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="系统调研" scheme="leeblog.icu/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>主机暴毙，PG驾崩，视图数据损坏修复过程</title>
    <link href="leeblog.icu/2022/12/07/"/>
    <id>leeblog.icu/2022/12/07/</id>
    <published>2022-12-07T12:30:19.000Z</published>
    <updated>2022-12-08T14:22:57.351Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ERROR:  </span>could not open file &quot;base/67201/11128463&quot;: No such file or directory</span><br></pre></td></tr></table></figure><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ERROR:  </span>cache lookup failed for relation 11128951</span><br></pre></td></tr></table></figure><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>测试环境postgreSQL数据库是以docker容器部署的单节点服务，机器在本地机房里。</p><p>测试服务器又又又突然挂了，重启机器后pg又又未能重启，参照<a href="https://leeblog.icu/2022/05/24/">记录机器断电后PG故障的解决</a><br>解决后，成功启动。</p><p>但成功启动后发现部分物化视图查询报错</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">could <span class="keyword">not</span> <span class="built_in">open</span> <span class="built_in">file</span> <span class="string">&quot;base/67201/11128463&quot;</span>: No such <span class="built_in">file</span> <span class="keyword">or</span> <span class="built_in">directory</span></span><br></pre></td></tr></table></figure><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><ul><li><p>猜测是由于服务器挂掉的时候，物化视图正在执行更新操作，突然断开导致视图数据文件损坏。</p></li><li><p>遂尝试刷新物化视图，以期待能够重建数据文件</p>  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">refresh materialized view  bi_view_real_time_sale_period_market_all;</span><br></pre></td></tr></table></figure><p>不曾想又报了一错：</p>  <figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">[XX000] ERROR: <span class="keyword">cache</span> lookup failed for relation <span class="number">11128466</span></span><br></pre></td></tr></table></figure></li><li><p>可想而知该视图已被锁定<br>尝试删除视图，失败，同样的锁定错误。</p></li><li><p>遂进行引用删除（注意备份视图创建语句）</p><ul><li><p>查询视图oid</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">oid</span>, relname,relfilenode <span class="keyword">from</span> pg_class <span class="keyword">where</span> relname <span class="keyword">like</span> <span class="string">&#x27;%bi_view_real_time_sale_period_market_all%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">row: 1066610,bi_view_real_time_sale_period_market_all</span><br></pre></td></tr></table></figure></li><li><p>删除引用</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> pg_class <span class="keyword">where</span> <span class="keyword">oid</span>=<span class="number">1066610</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> pg_depend <span class="keyword">where</span> objid=<span class="number">1066610</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> pg_depend <span class="keyword">where</span> refclassid=<span class="number">1066610</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> pg_depend <span class="keyword">where</span> refobjid=<span class="number">1066610</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除type</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">type</span>  bi_view_real_time_sale_period_market_all;</span><br></pre></td></tr></table></figure></li><li><p>重建视图,执行成功</p></li></ul></li></ul><p><strong>本文作者</strong>：Lee<br/><strong>本文地址</strong>： <a href="leeblog.icu/2022/12/07/">leeblog.icu/2022/12/07/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC 4.0 BY-NC-SA</a> 许可协议。转载请注明出处！</p>]]></content>
    
    
    <summary type="html">测试服务器又又又突然挂了，重启机器后pg又又未能重启，一番操作后，成功启动。但成功启动后发现部分物化视图查询报错...</summary>
    
    
    
    <category term="技术" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="postgres" scheme="leeblog.icu/tags/postgres/"/>
    
  </entry>
  
  <entry>
    <title>Arch系统磁盘空间清理</title>
    <link href="leeblog.icu/2022/08/22/"/>
    <id>leeblog.icu/2022/08/22/</id>
    <published>2022-08-22T05:33:59.000Z</published>
    <updated>2022-08-22T15:55:34.803Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pacman-yay-无用软件包清理"><a href="#pacman-yay-无用软件包清理" class="headerlink" title="pacman/yay 无用软件包清理"></a>pacman/yay 无用软件包清理</h3><p><code>大概5GB</code></p><p>清理旧版本包及已卸载的包：<br> <figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">pacman -Scc</span></span><br></pre></td></tr></table></figure></p><p>清理孤立的未使用的包：<br> <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">pacman -R (<span class="name">pacman</span> -Qdtq)</span><br></pre></td></tr></table></figure></p><h3 id="systemd日志文件清理与存储设置"><a href="#systemd日志文件清理与存储设置" class="headerlink" title="systemd日志文件清理与存储设置"></a>systemd日志文件清理与存储设置</h3><p><code>大概4GB</code></p><p>推荐：设置最大存储时间：</p> <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">journalctl <span class="attribute">--vacuum-time</span>=1months</span><br></pre></td></tr></table></figure><p>设置最大存储量：</p> <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">journalctl <span class="attribute">--vacuum-size</span>=50M</span><br></pre></td></tr></table></figure><p>（按需选择其一即可）</p><p><strong>本文作者</strong>：Lee<br/><strong>本文地址</strong>： <a href="leeblog.icu/2022/08/22/">leeblog.icu/2022/08/22/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC 4.0 BY-NC-SA</a> 许可协议。转载请注明出处！</p>]]></content>
    
    
    <summary type="html">某日公司办公电脑磁盘空间告警，遂进行清理，记录一下</summary>
    
    
    
    <category term="技术" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="linux" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/linux/"/>
    
    
    <category term="arch" scheme="leeblog.icu/tags/arch/"/>
    
    <category term="linux" scheme="leeblog.icu/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>PG下FDW插件使用</title>
    <link href="leeblog.icu/2022/06/29/"/>
    <id>leeblog.icu/2022/06/29/</id>
    <published>2022-06-29T11:35:58.000Z</published>
    <updated>2022-06-29T15:11:32.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>postgres fdw是一种外部访问接口，它可以被用来访问存储在外部的数据，这些数据可以是外部的pg数据库，也可以oracle、mysql、mongo、redis等数据库，甚至可以是文件。</p><p>截止到目前为止, 全世界已有了成百上千种数据源有了相应的FDW实现, 从传统的文件系统到各种新型的Nosql数据库, 甚至还包括互联网上的Web Service。</p><p>目前支持的fdw外部数据源：<a href="https://wiki.postgresql.org/wiki/Foreign_data_wrappers">https://wiki.postgresql.org/wiki/Foreign_data_wrappers</a></p><p>使用FDW的核心就在于使用外部表。尽管面向不同数据源的FDW实现各有不同, 但是受益于SQL/MED定义的标准, 创建不同数据源的外部表的方法都是一样的, 这里我们拿mysql_fdw做示例。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><code>执行sql访问外部数据源</code>-&gt;<code>sql解析</code>-&gt;<code>下推至外部数据源执行</code>-&gt;<code>返回数据结果</code></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--向PG安装某个数据源的FDW扩展</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTENSION</span> mysql_fdw;</span><br><span class="line"><span class="comment">--drop EXTENSION mysql_fdw;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--创建该数据源的FDW对象</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FOREIGN DATA</span> <span class="keyword">WRAPPER</span> mysql_fdw;</span><br><span class="line"><span class="comment">--DROP  FOREIGN DATA WRAPPER mysql_fdw;</span></span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="1-创建该数据源的服务器对象"><a href="#1-创建该数据源的服务器对象" class="headerlink" title="1.创建该数据源的服务器对象"></a>1.创建该数据源的服务器对象</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">--创建服务连接信息</span><br><span class="line">CREATE<span class="built_in"> SERVER </span>erp_server</span><br><span class="line">     FOREIGN DATA WRAPPER mysql_fdw</span><br><span class="line">     OPTIONS (host <span class="string">&#x27;172.16.0.70&#x27;</span>,<span class="built_in"> port </span><span class="string">&#x27;3306&#x27;</span>);</span><br><span class="line">--DROP<span class="built_in"> SERVER </span>erp_server;</span><br><span class="line"></span><br><span class="line">--建立用户映射 `bitest`当前pg用户，`rwbj`外部数据源用户</span><br><span class="line">CREATE<span class="built_in"> USER </span>MAPPING <span class="keyword">FOR</span> bitest</span><br><span class="line">SERVER erp_server</span><br><span class="line">OPTIONS (username <span class="string">&#x27;rwbj&#x27;</span>, password <span class="string">&#x27;22eaa714ae0b49e09808233f3d3d6212&#x27;</span>);</span><br><span class="line"></span><br><span class="line">--DROP<span class="built_in"> USER </span>MAPPING <span class="keyword">FOR</span> bitest<span class="built_in"> SERVER </span>erp_server</span><br></pre></td></tr></table></figure><h3 id="2-创建外部表（三种方式）"><a href="#2-创建外部表（三种方式）" class="headerlink" title="2. 创建外部表（三种方式）"></a>2. 创建外部表（三种方式）</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">--创建外部数据表（指定字段）</span><br><span class="line">CREATE FOREIGN TABLE erp_contract (id bigint)<span class="built_in"> server </span>erp_server</span><br><span class="line">    options (dbname <span class="string">&#x27;erp&#x27;</span>, table_name <span class="string">&#x27;erp_contract&#x27;</span>);</span><br><span class="line"></span><br><span class="line">--除了指定字段创建外部表以外，还可以直接导入指定表的所有字段</span><br><span class="line">import foreign schema erp limit <span class="keyword">to</span> (erp_rent_shop,erp_sys_user) <span class="keyword">from</span><span class="built_in"> server </span>erp_server into bi;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 以及，一次性导入指定DB下的所有表</span><br><span class="line">import foreign schema erp <span class="keyword">from</span><span class="built_in"> server </span>erp_server into bi;</span><br></pre></td></tr></table></figure><h3 id="3-使用外部表"><a href="#3-使用外部表" class="headerlink" title="3. 使用外部表"></a>3. 使用外部表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--然后，像对自家表一样操作外部数据源mysql</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> erp_contract;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> erp_contract (<span class="keyword">id</span>) <span class="keyword">values</span> (<span class="number">1</span>);</span><br><span class="line"><span class="keyword">update</span> erp_contract <span class="keyword">set</span> <span class="keyword">id</span>= <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> erp_contract <span class="keyword">where</span> <span class="keyword">id</span>  = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="4-删除外部表"><a href="#4-删除外部表" class="headerlink" title="4. 删除外部表"></a>4. 删除外部表</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 指定表名称，删除多个外部表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">foreign</span> <span class="keyword">table</span> bi.erp_contract, bi.erp_rent_shop;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 或者构造sql语句批量删除</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="string">&#x27;drop foreign table &#x27;</span> || t.table_schema || <span class="string">&#x27;.&#x27;</span> || t.<span class="built_in">table_name</span> || <span class="string">&#x27;;&#x27;</span> <span class="keyword">as</span> drop_sql</span><br><span class="line"><span class="keyword">from</span> information_schema.<span class="keyword">tables</span> t</span><br><span class="line"><span class="keyword">where</span> t.table_type <span class="keyword">in</span> (<span class="string">&#x27;FOREIGN&#x27;</span>)</span><br><span class="line"><span class="keyword">and</span> t.table_schema <span class="keyword">in</span> (<span class="string">&#x27;bi&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-扩展"><a href="#5-扩展" class="headerlink" title="5.扩展"></a>5.扩展</h3><p>由FDW实现原理可知，PG本身没有对外部数据源进行存储管理（也不可能），每次访问都是通过下推到外部数据库进行的执行。对于读数据频次较大、或数据量较多、或复杂查询的场景（比如BI统计），我们可以通过物化外部数据来减轻对外部数据源的压力和执行开销，如下：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--创建物化视图</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">MATERIALIZED</span> <span class="keyword">VIEW</span> erp_contract_view <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> erp_contract;</span><br><span class="line"><span class="comment">--定期刷新物化视图</span></span><br><span class="line"><span class="keyword">REFRESH</span> <span class="keyword">MATERIALIZED</span> <span class="keyword">VIEW</span> erp_contract_view;</span><br></pre></td></tr></table></figure><p>也可以创建pg本地表来对第三方数据源的数据进行定期增量同步：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--创建pg本地表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  erp_contract_t <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> erp_contract;</span><br><span class="line"><span class="comment">--同步数据</span></span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> erp_contract_t t</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> erp_contract f <span class="keyword">WHERE</span> t.id = f.id);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> erp_contract_t      <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> erp_contract;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之前一直没有使用过pg的fdw扩展,因为EAM的数据可视化需求的实现方案涉及到了，所以去了解试用了一下。</p><p>方便规范，整体可用，直接免去了在星汉内部系统中数据共享与交换的开发成本。</p><p>但该方案跟育铜讨论后，育铜提出了后期维护与管理不透明的主张。确是如此，我明白后期维护与管理的弊端。</p><p>但我没想明白的是：如果如此的话，FDW的存在还有什么意义呢？也许FDW还需要一个web管理？我不知道Pigsty是否对此作了支持，后面去看一下。</p><p><strong>本文作者</strong>：Lee<br/><strong>本文地址</strong>： <a href="leeblog.icu/2022/06/29/">leeblog.icu/2022/06/29/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC 4.0 BY-NC-SA</a> 许可协议。转载请注明出处！</p>]]></content>
    
    
    <summary type="html">postgres fdw是一种外部访问接口，它可以被用来访问存储在外部的数据，这些数据可以是外部的pg数据库，也可以oracle、mysql、mongo、redis等数据库，甚至可以是文件。</summary>
    
    
    
    <category term="技术" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="postgres" scheme="leeblog.icu/tags/postgres/"/>
    
  </entry>
  
  <entry>
    <title>当PG遇上Mysql</title>
    <link href="leeblog.icu/2022/06/22/"/>
    <id>leeblog.icu/2022/06/22/</id>
    <published>2022-06-21T16:38:48.000Z</published>
    <updated>2022-06-29T15:09:58.047Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是PG？"><a href="#什么是PG？" class="headerlink" title="什么是PG？"></a>什么是PG？</h3><p>PostgreSQL是一个功能强大且完全开源的数据库。它提供了单个完整功能的版本，而不像MySQL那样提供了多个不同的社区版、商业版与企业版。<br>PostgreSQL基于自由的BSD/MIT许可，任何组织可以任意使用、修改以及重新分发代码。事实上国内阿里以及腾讯号称自研的商业数据库也都是基于PostgreSQL衍生的。</p><h3 id="为什么是PG？"><a href="#为什么是PG？" class="headerlink" title="为什么是PG？"></a>为什么是PG？</h3><blockquote><p>一切都是相对的，一切事物都需要参照物，没有对比就没有优劣。虽然PG方方面面对标的一直是Oracle，但是由于Oracle收费，所以我们在技术选型时，往往会将MySQL跟PG做对比，所以我们在这里也选择MySQL来吊打。</p></blockquote><h4 id="总体描述"><a href="#总体描述" class="headerlink" title="总体描述"></a>总体描述</h4><ul><li><code>PG</code>：”最先进的开源关系型数据库“。</li><li><code>MySQL</code>：”最流行的开源关系型数据库“。</li></ul><h4 id="商业环境"><a href="#商业环境" class="headerlink" title="商业环境"></a>商业环境</h4><ul><li><p><code>开源协议</code>：PG遵循BSD/MIT许可,任何企业任何组织可以任意使用甚至修改再盈利，而MySQL基于GPL许可,也允许企业免费使用，但随着MySQL被oracle公司收购，在商业版和社区版之间的功能取舍上也难免会有厚此薄彼之嫌。<code>PG赢</code></p></li><li><p><code>发行版本</code>：PG提供了单个完整功能的版本，MySQL提供了多个不同的社区版、商业版与企业版。<code>PG赢</code></p></li><li><p><code>大版本发布速度</code>: PG每年一个大版本发布，大版本发布的第二年就可以上生产环境，版本迭代速度很快。MySQL的大版本发布一般是2年~3年，一般大版本发布后的第二年才可以上生产环境，避免有坑，版本发布速度比较慢。这也是由于MySQL的维护者是商业公司导致，各有优劣。<code>平局</code></p></li><li><p><code>流行趋势</code>：不可否认MySQL依旧是当前Web项目中的顶流，开发者MySQL技能必备，对PG有一定技术积累的还是相对较少。但近年来PG也在慢慢进入人们的视野，流行度呈逐步上升的趋势。MySQL赢。</p></li></ul><h4 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h4><ul><li><p><code>支持的数据类型</code>：由于PG的大而全，所以整个PG的复杂度相对较高，从PG支持的数据类型里可见一斑，常见的数值、文本、日期、布尔、json等基础类型支持不必赘述，其他类型几乎应有仅有，如货币类型、网络地址类型、枚举类型、几何类型、文本搜索类型（支持全文检索及分词）、XML类型、数组类型、范围类型等等等。甚至你可以自定义一个对象类型。而MySQL仅支持基础类型。<code>PG赢</code></p></li><li><p><code>索引类型</code>：<br>PG支持多种索引类型btree , hash , gin , gist , sp-gist , brin , bloom , rum , zombodb , bitmap，部分索引，表达式索引;MySQL仅支持btree 索引，全文索引（低效），表达式索引(需要建虚拟列)，hash 索引只在内存表。<code>PG赢</code></p></li><li><p><code>SQL特性支持</code>:<br>PGSQL特性支持94种，SQL语法支持最完善，例如：支持公用表表达式（WITH查询、窗口函数、递归查询等）。MySQL的SQL特性支持情况支持36种，SQL语法支持比较弱，WITH查询、窗口函数、递归查询概不支持。PG赢。</p></li><li><p><code>DDL操作</code>：PGSQL加字段、可变长字段类型长度改大不会锁表，所有的DDL操作都不需要借助第三方工具，并且跟商业数据库一样，DDL操作可以回滚，保证事务一致性。<br>而MySQL由于大部分DDL操作都会锁表，例如加字段、可变长字段类型长度改大，特别是对大表进行DDL操作DDL操作不能回滚。PG赢。</p></li><li><p>物化视图：PGSQL支持物化视图;MySQL不支持物化视图。PG赢。</p></li><li><p><code>MVCC机制实现的区别</code>：MySQL基于回滚段实现的MVCC机制,但是MySQL的间隙锁影响较大，锁定数据较多，对高并发的支持有限。PG基于XID的MVCC机制进行多版本存储,保证了对高并发的支持，解决了数据库常见瓶颈问题。这种机制也导致PG的维护成本稍微高了那么一点点（需要定期VACUUM）。不考虑业务场景的情况下，平局。</p></li></ul><h4 id="运行维护"><a href="#运行维护" class="headerlink" title="运行维护"></a>运行维护</h4><ul><li><p><code>CPU限制</code>：PGSQL没有CPU核心数限制，有多少CPU核就用多少MySQL能用128核CPU，超过128核用不上。PG赢。</p></li><li><p><code>配置文件参数</code>：PGSQL一共有255个参数，用到的大概是80个，参数比较稳定，用上个大版本配置文件也可以启动当前大版本数据库。MySQL一共有707个参数，用到的大概是180个，参数不断增加，就算小版本也会增加参数，大版本之间会有部分参数不兼容情况。PG赢。</p></li><li><p><code>第三方工具依赖情况</code>：PG只有高可用集群需要依靠第三方中间件，例如：patroni+etcd、repmgr; MySQL大部分操作都要依靠percona公司的第三方工具（percona-toolkit，XtraBackup），工具命令太多，学习成本高，高可用集群也需要第三方中间件，官方MGR集群还没成熟。PG赢。</p></li><li><p><code>高可用主从复制底层原理</code>: PG物理流复制，属于物理复制，跟SQL Server镜像/AlwaysOn一样，严格一致，没有任何可能导致不一致，性能和可靠性上，物理复制完胜逻辑复制，维护简单MySQL主从复制，属于逻辑复制，（sql_log_bin、binlog_format等参数设置不正确都会导致主从不一致）大事务并行复制效率低。PG赢。</p></li></ul><h4 id="学习曲线"><a href="#学习曲线" class="headerlink" title="学习曲线"></a>学习曲线</h4><p>对于简单的业务逻辑，MySQL与PG在性能和效率上并没有太大差距，在开发效率上切换成本并没有很高，相当于之前MySQL现在切换成Oracle，CRUD语句并没有太大差别。<br>而对于复杂的查询统计逻辑，MySQL和PG在性能和执行效率上是有天壤之别的，在开发效率上基本没啥可比性，因为MySQL它根本就不支持一些复杂的逻辑查询。而开发者确实是需要不断提升对PG特性的熟悉程度，才能快速的开发。而这种丰富性或者说是复杂性，恰恰是PG的优势，并非PG的缺陷。 平局。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>MySQL是应用开发者创建出来的DBMS；而PostgreSQL是由数据库开发者创建出来的DBMS 。换句话说，MySQL倾向于使用者的角度，回答的问题是 “你想解决的是什么问题”；而PostgreSQL倾向于理论角度，回答的问题是 “数据库应该如何来解决问题” 。</p><p>MySQL一般会将数据合法性验证交给客户；PostgreSQL在合法性方面做得比较严格。比如MySQL里插入 “2012-02-30” 这个时间时，会成功，但结果会是 “0000-00-00”；PostgreSQL不允许插入此值。</p><p>通常，PostgreSQL 被认为特性丰富，且对复杂查询的效率更高，而MySQL被认为在简单查询速度更快。但这个观点基本是在 MySQL 4.x / PostgreSQL 7.x 的事情，现在情况已经变了，PostgreSQL 在9.x版本速度上有了很大的改进，而MySQL特性也在增加(但MySQL的商业背景决定了它无法在特性支持上跟PG比拟)。</p><p>从应用场景来说，PG更加适合严格的企业应用场景（比如BI、金融、电信、ERP、CRM），而MySQL更加适合业务逻辑相对简单、数据可靠性要求较低的互联网场景（其实相对PG来说也有并发插入的瓶颈问题）。PG赢麻了。</p><h3 id="怎么开始？"><a href="#怎么开始？" class="headerlink" title="怎么开始？"></a>怎么开始？</h3><p>我相信随着外界技术环境的不断升级、随着我们项目的不断优化，会有越來越多的系统会对PG予以青睐，欢迎拥抱PostgreSQL。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.postgresql.org/about/">https://www.postgresql.org/about/</a></p><p><a href="https://www.runoob.com/postgresql/postgresql-tutorial.html">https://www.runoob.com/postgresql/postgresql-tutorial.html</a></p><p><a href="https://www.biaodianfu.com/mysql-vs-postgresql.html">https://www.biaodianfu.com/mysql-vs-postgresql.html</a></p><p><a href="https://www.zhihu.com/question/20010554/answer/2320511271">https://www.zhihu.com/question/20010554/answer/2320511271</a></p><p><a href="https://www.zhihu.com/question/20010554/answer/2280773945">https://www.zhihu.com/question/20010554/answer/2280773945</a></p><p><strong>本文作者</strong>：Lee<br/><strong>本文地址</strong>： <a href="leeblog.icu/2022/06/22/">leeblog.icu/2022/06/22/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC 4.0 BY-NC-SA</a> 许可协议。转载请注明出处！</p>]]></content>
    
    
    <summary type="html">一切都是相对的，一切事物都需要参照物，没有对比就没有优劣。虽然PG方方面面对标的一直是Oracle，但是由于Oracle收费，所以我们在技术选型时，往往会将MySQL跟PG做对比，所以我们在这里也选择MySQL来吊打</summary>
    
    
    
    <category term="技术" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="postgres" scheme="leeblog.icu/tags/postgres/"/>
    
  </entry>
  
  <entry>
    <title>PG下常用的自建函数</title>
    <link href="leeblog.icu/2022/06/03/"/>
    <id>leeblog.icu/2022/06/03/</id>
    <published>2022-06-02T16:22:48.000Z</published>
    <updated>2022-06-03T14:26:47.357Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>适度的抽取逻辑来组装函数，有助于提升开发效率及后期维护的便捷性,本文列举了本人在BI开发过程中所封装的函数供大家参考。</p></blockquote><h3 id="数值计算类"><a href="#数值计算类" class="headerlink" title="数值计算类"></a>数值计算类</h3><ul><li>除法计算，保留两位小数</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> divide(divisor <span class="built_in">numeric</span>, divisor2 <span class="built_in">numeric</span>) <span class="keyword">returns</span> <span class="built_in">numeric</span></span><br><span class="line">    <span class="keyword">language</span> plpgsql</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="comment">-- 若除数等于0或为null 直接返回0.00</span></span><br><span class="line"><span class="keyword">if</span>  divisor2 = <span class="number">0</span>  <span class="keyword">or</span>  divisor2 <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">RETURN</span> <span class="number">0.00</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--round结果保留两位</span></span><br><span class="line">  RETURN COALESCE(round(COALESCE(divisor/divisor2,0),2),0);</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$$;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>除法计算，自定义精度</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> divide_scale(divisor <span class="built_in">numeric</span>, divisor2 <span class="built_in">numeric</span>, round_scale <span class="built_in">integer</span>) <span class="keyword">returns</span> <span class="built_in">numeric</span></span><br><span class="line">    <span class="keyword">language</span> plpgsql</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="comment">-- 除法函数自定义精度...</span></span><br><span class="line">  <span class="comment">-- 若除数等于0或为null 直接返回0</span></span><br><span class="line"><span class="keyword">if</span>  divisor2 = <span class="number">0</span>  <span class="keyword">or</span>  divisor2 <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">RETURN</span> <span class="keyword">round</span>(<span class="number">0</span>,round_scale);</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"></span><br><span class="line">  RETURN round(COALESCE(divisor/NULLIF(divisor2,0),0),round_scale);</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$$;</span><br></pre></td></tr></table></figure><ul><li>百分比比值计算,保留两位小数</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> percent_prop(divisor <span class="built_in">numeric</span>, divisor2 <span class="built_in">numeric</span>) <span class="keyword">returns</span> <span class="built_in">numeric</span></span><br><span class="line">    <span class="keyword">language</span> plpgsql</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="comment">-- 若除数等于0或为null 直接返回0</span></span><br><span class="line"><span class="keyword">if</span>  divisor2 = <span class="number">0</span>  <span class="keyword">or</span>  divisor2 <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">RETURN</span> <span class="number">0.00</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"></span><br><span class="line">  RETURN round(round(COALESCE(divisor/NULLIF(divisor2,0),0),4)*100,2);</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$$;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数组处理类"><a href="#数组处理类" class="headerlink" title="数组处理类"></a>数组处理类</h3><ul><li>数组去重</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> array_distinct(anyarray) <span class="keyword">returns</span> anyarray</span><br><span class="line">    <span class="keyword">language</span> <span class="keyword">sql</span></span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">ARRAY</span>(<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="keyword">unnest</span>($<span class="number">1</span>));</span><br><span class="line">$$;</span><br></pre></td></tr></table></figure><ul><li>数组最大值</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> array_max(anyarray) <span class="keyword">returns</span> anyelement</span><br><span class="line">    <span class="keyword">language</span> <span class="keyword">sql</span></span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">max</span>(x) <span class="keyword">FROM</span> <span class="keyword">unnest</span>($<span class="number">1</span>) <span class="keyword">as</span> x;</span><br><span class="line">$$;</span><br></pre></td></tr></table></figure><ul><li>数组最小值</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> array_min(anyarray) <span class="keyword">returns</span> anyelement</span><br><span class="line">    <span class="keyword">language</span> <span class="keyword">sql</span></span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">min</span>(x) <span class="keyword">FROM</span> <span class="keyword">unnest</span>($<span class="number">1</span>) <span class="keyword">as</span> x;</span><br><span class="line">$$;</span><br></pre></td></tr></table></figure><h3 id="更新被依赖对象DDL工具函数"><a href="#更新被依赖对象DDL工具函数" class="headerlink" title="更新被依赖对象DDL工具函数"></a>更新被依赖对象DDL工具函数</h3><blockquote><p>我们在修改视图定义时，如果该视图有被其他视图或函数依赖的话，是无法直接删除并更新的，只能找到所有依赖该视图的对象，依次备份后删除才能对该视图进行更新。随着业务的复杂，依赖关系也变的复杂，这项工作比较耗时耗力，所以就有了该函数，自动查询所有依赖，对依赖DDl保存并自动删除。更新该视图后，再次执行函数，自动对依赖进行恢复。</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--依赖DDL暂存表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> deps_saved_ddl</span><br><span class="line">(</span><br><span class="line">    deps_id          <span class="built_in">integer</span> <span class="keyword">default</span> <span class="keyword">nextval</span>(<span class="string">&#x27;deps_saved_ddl_deps_id_seq&#x27;</span>::regclass) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">        primary <span class="keyword">key</span>,</span><br><span class="line">    deps_view_schema <span class="keyword">name</span>,</span><br><span class="line">    deps_view_name   <span class="keyword">name</span>,</span><br><span class="line">    deps_ddl_to_run  <span class="built_in">text</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">--自动查询依赖并保存后删除函数</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> deps_save_and_drop_dependencies(p_view_schema <span class="keyword">name</span>, p_view_name <span class="keyword">name</span>) <span class="keyword">returns</span> <span class="built_in">void</span></span><br><span class="line">    <span class="keyword">language</span> plpgsql</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">declare</span></span><br><span class="line">  v_curr <span class="built_in">record</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">for</span> v_curr <span class="keyword">in</span> </span><br><span class="line">(</span><br><span class="line">  <span class="keyword">select</span> obj_schema, obj_name, obj_type <span class="keyword">from</span></span><br><span class="line">  (</span><br><span class="line">  <span class="keyword">with</span> <span class="keyword">recursive</span> recursive_deps(obj_schema, obj_name, obj_type, <span class="keyword">depth</span>) <span class="keyword">as</span> </span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">select</span> p_view_schema, p_view_name, <span class="literal">null</span>::<span class="built_in">char</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    <span class="keyword">select</span> dep_schema::<span class="keyword">name</span>, dep_name::<span class="keyword">name</span>, dep_type::<span class="built_in">char</span>, recursive_deps.depth + <span class="number">1</span> <span class="keyword">from</span> </span><br><span class="line">    (</span><br><span class="line">      <span class="keyword">select</span> ref_nsp.nspname ref_schema, ref_cl.relname ref_name, </span><br><span class="line">  rwr_cl.relkind dep_type,</span><br><span class="line">      rwr_nsp.nspname dep_schema,</span><br><span class="line">      rwr_cl.relname dep_name</span><br><span class="line">      <span class="keyword">from</span> pg_depend dep</span><br><span class="line">      <span class="keyword">join</span> pg_class ref_cl <span class="keyword">on</span> dep.refobjid = ref_cl.oid</span><br><span class="line">      <span class="keyword">join</span> pg_namespace ref_nsp <span class="keyword">on</span> ref_cl.relnamespace = ref_nsp.oid</span><br><span class="line">      <span class="keyword">join</span> pg_rewrite rwr <span class="keyword">on</span> dep.objid = rwr.oid</span><br><span class="line">      <span class="keyword">join</span> pg_class rwr_cl <span class="keyword">on</span> rwr.ev_class = rwr_cl.oid</span><br><span class="line">      <span class="keyword">join</span> pg_namespace rwr_nsp <span class="keyword">on</span> rwr_cl.relnamespace = rwr_nsp.oid</span><br><span class="line">      <span class="keyword">where</span> dep.deptype = <span class="string">&#x27;n&#x27;</span></span><br><span class="line">      <span class="keyword">and</span> dep.classid = <span class="string">&#x27;pg_rewrite&#x27;</span>::regclass</span><br><span class="line">    ) deps</span><br><span class="line">    <span class="keyword">join</span> recursive_deps <span class="keyword">on</span> deps.ref_schema = recursive_deps.obj_schema <span class="keyword">and</span> deps.ref_name = recursive_deps.obj_name</span><br><span class="line">    <span class="keyword">where</span> (deps.ref_schema != deps.dep_schema <span class="keyword">or</span> deps.ref_name != deps.dep_name)</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">select</span> obj_schema, obj_name, obj_type, <span class="keyword">depth</span></span><br><span class="line">  <span class="keyword">from</span> recursive_deps </span><br><span class="line">  <span class="keyword">where</span> <span class="keyword">depth</span> &gt; <span class="number">0</span></span><br><span class="line">  ) t</span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> obj_schema, obj_name, obj_type</span><br><span class="line">  <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">max</span>(<span class="keyword">depth</span>) <span class="keyword">desc</span></span><br><span class="line">) <span class="keyword">loop</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> deps_saved_ddl(deps_view_schema, deps_view_name, deps_ddl_to_run)</span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">distinct</span> p_view_schema, p_view_name, indexdef</span><br><span class="line">  <span class="keyword">from</span> pg_indexes</span><br><span class="line">  <span class="keyword">where</span> schemaname = v_curr.obj_schema</span><br><span class="line">  <span class="keyword">and</span> tablename = v_curr.obj_name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> deps_saved_ddl(deps_view_schema, deps_view_name, deps_ddl_to_run)</span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">distinct</span> tablename, rulename, definition</span><br><span class="line">  <span class="keyword">from</span> pg_rules</span><br><span class="line">  <span class="keyword">where</span> schemaname = v_curr.obj_schema</span><br><span class="line">  <span class="keyword">and</span> tablename = v_curr.obj_name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> deps_saved_ddl(deps_view_schema, deps_view_name, deps_ddl_to_run)</span><br><span class="line">  <span class="keyword">select</span> p_view_schema, p_view_name, <span class="string">&#x27;COMMENT ON &#x27;</span> ||</span><br><span class="line">  <span class="keyword">case</span></span><br><span class="line">  <span class="keyword">when</span> c.relkind = <span class="string">&#x27;v&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;VIEW&#x27;</span></span><br><span class="line">  <span class="keyword">when</span> c.relkind = <span class="string">&#x27;m&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;MATERIALIZED VIEW&#x27;</span></span><br><span class="line">  <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  || <span class="string">&#x27; &#x27;</span> || n.nspname || <span class="string">&#x27;.&#x27;</span> || c.relname || <span class="string">&#x27; IS &#x27;&#x27;&#x27;</span> || <span class="keyword">replace</span>(d.description, <span class="string">&#x27;&#x27;&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;</span>) || <span class="string">&#x27;&#x27;&#x27;;&#x27;</span></span><br><span class="line">  <span class="keyword">from</span> pg_class c</span><br><span class="line">  <span class="keyword">join</span> pg_namespace n <span class="keyword">on</span> n.oid = c.relnamespace</span><br><span class="line">  <span class="keyword">join</span> pg_description d <span class="keyword">on</span> d.objoid = c.oid <span class="keyword">and</span> d.objsubid = <span class="number">0</span></span><br><span class="line">  <span class="keyword">where</span> n.nspname = v_curr.obj_schema <span class="keyword">and</span> c.relname = v_curr.obj_name <span class="keyword">and</span> d.description <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> deps_saved_ddl(deps_view_schema, deps_view_name, deps_ddl_to_run)</span><br><span class="line">  <span class="keyword">select</span> p_view_schema, p_view_name, <span class="string">&#x27;COMMENT ON COLUMN &#x27;</span> || n.nspname || <span class="string">&#x27;.&#x27;</span> || c.relname || <span class="string">&#x27;.&#x27;</span> || a.attname || <span class="string">&#x27; IS &#x27;&#x27;&#x27;</span> || <span class="keyword">replace</span>(d.description, <span class="string">&#x27;&#x27;&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;</span>) || <span class="string">&#x27;&#x27;&#x27;;&#x27;</span></span><br><span class="line">  <span class="keyword">from</span> pg_class c</span><br><span class="line">  <span class="keyword">join</span> pg_attribute a <span class="keyword">on</span> c.oid = a.attrelid</span><br><span class="line">  <span class="keyword">join</span> pg_namespace n <span class="keyword">on</span> n.oid = c.relnamespace</span><br><span class="line">  <span class="keyword">join</span> pg_description d <span class="keyword">on</span> d.objoid = c.oid <span class="keyword">and</span> d.objsubid = a.attnum</span><br><span class="line">  <span class="keyword">where</span> n.nspname = v_curr.obj_schema <span class="keyword">and</span> c.relname = v_curr.obj_name <span class="keyword">and</span> d.description <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> deps_saved_ddl(deps_view_schema, deps_view_name, deps_ddl_to_run)</span><br><span class="line">  <span class="keyword">select</span> p_view_schema, p_view_name, <span class="string">&#x27;GRANT &#x27;</span> || privilege_type || <span class="string">&#x27; ON &#x27;</span> || table_schema || <span class="string">&#x27;.&#x27;</span> || quote_ident(table_name) || <span class="string">&#x27; TO &#x27;</span> || grantee</span><br><span class="line">  <span class="keyword">from</span> information_schema.role_table_grants</span><br><span class="line">  <span class="keyword">where</span> table_schema = v_curr.obj_schema <span class="keyword">and</span> table_name = v_curr.obj_name;</span><br><span class="line">  </span><br><span class="line">  if v_curr.obj_type = &#x27;v&#x27; then</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> deps_saved_ddl(deps_view_schema, deps_view_name, deps_ddl_to_run)</span><br><span class="line">    <span class="keyword">select</span> p_view_schema, p_view_name, <span class="string">&#x27;CREATE VIEW &#x27;</span> || v_curr.obj_schema || <span class="string">&#x27;.&#x27;</span> || quote_ident(v_curr.obj_name) || <span class="string">&#x27; AS &#x27;</span> || view_definition</span><br><span class="line">    <span class="keyword">from</span> information_schema.views</span><br><span class="line">    <span class="keyword">where</span> table_schema = v_curr.obj_schema <span class="keyword">and</span> table_name = v_curr.obj_name;</span><br><span class="line">  elsif v_curr.obj_type = &#x27;m&#x27; then</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> deps_saved_ddl(deps_view_schema, deps_view_name, deps_ddl_to_run)</span><br><span class="line">    <span class="keyword">select</span> p_view_schema, p_view_name, <span class="string">&#x27;CREATE MATERIALIZED VIEW &#x27;</span> || v_curr.obj_schema || <span class="string">&#x27;.&#x27;</span> || quote_ident(v_curr.obj_name) || <span class="string">&#x27; AS &#x27;</span> || definition</span><br><span class="line">    <span class="keyword">from</span> pg_matviews</span><br><span class="line">    <span class="keyword">where</span> schemaname = v_curr.obj_schema <span class="keyword">and</span> matviewname = v_curr.obj_name;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">execute</span> <span class="string">&#x27;DROP &#x27;</span> ||</span><br><span class="line">  <span class="keyword">case</span> </span><br><span class="line">    <span class="keyword">when</span> v_curr.obj_type = <span class="string">&#x27;v&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;VIEW&#x27;</span></span><br><span class="line">    <span class="keyword">when</span> v_curr.obj_type = <span class="string">&#x27;m&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;MATERIALIZED VIEW&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  || <span class="string">&#x27; &#x27;</span> || v_curr.obj_schema || <span class="string">&#x27;.&#x27;</span> || quote_ident(v_curr.obj_name);</span><br><span class="line">  </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">loop</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">$$;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 依赖恢复函数</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> deps_restore_dependencies(p_view_schema <span class="keyword">name</span>, p_view_name <span class="keyword">name</span>) <span class="keyword">returns</span> <span class="built_in">void</span></span><br><span class="line">    <span class="keyword">language</span> plpgsql</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">declare</span></span><br><span class="line">  v_curr <span class="built_in">record</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">for</span> v_curr <span class="keyword">in</span> </span><br><span class="line">(</span><br><span class="line">  <span class="keyword">select</span> deps_ddl_to_run </span><br><span class="line">  <span class="keyword">from</span> deps_saved_ddl</span><br><span class="line">  <span class="keyword">where</span> deps_view_schema = p_view_schema <span class="keyword">and</span> deps_view_name = p_view_name</span><br><span class="line">  <span class="keyword">order</span> <span class="keyword">by</span> deps_id <span class="keyword">desc</span></span><br><span class="line">) <span class="keyword">loop</span></span><br><span class="line">  <span class="keyword">execute</span> v_curr.deps_ddl_to_run;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">loop</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> deps_saved_ddl</span><br><span class="line"><span class="keyword">where</span> deps_view_schema = p_view_schema <span class="keyword">and</span> deps_view_name = p_view_name;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">$$;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>本文作者</strong>：Lee<br/><strong>本文地址</strong>： <a href="leeblog.icu/2022/06/03/">leeblog.icu/2022/06/03/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC 4.0 BY-NC-SA</a> 许可协议。转载请注明出处！</p>]]></content>
    
    
    <summary type="html">适度的抽取逻辑来组装函数，有助于提升开发效率及后期维护的便捷性,本文列举了本人在BI开发过程中所封装的函数供大家参考。</summary>
    
    
    
    <category term="技术" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="postgres" scheme="leeblog.icu/tags/postgres/"/>
    
  </entry>
  
  <entry>
    <title>PG窗口函数的应用实践</title>
    <link href="leeblog.icu/2022/05/26/"/>
    <id>leeblog.icu/2022/05/26/</id>
    <published>2022-05-26T11:25:48.000Z</published>
    <updated>2022-05-26T09:43:23.271Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>窗口函数主要用于聚合计算，相当于我们的分组语句group by。<br>常用的sql语句往往只支持单一的数据范围统计，而窗口函数支持更加灵活更加多样的数据范围划定。<br>本质上，是否需要使用窗口函数，取决于你的需求场景是否涉及到同一种事物的不同数据范围的同时计算。</p><h3 id="排名类"><a href="#排名类" class="headerlink" title="排名类"></a>排名类</h3><p>排名，普通的只涉及到单一数据范围的排名的话，我们只需要正常的排序就可以满足，当你需要同时计算每个单位在不同数据范围下的排名计算，就需要使用窗口函数，<br>比如各个店铺销售额在楼层中的排名、在所属业态中的排名、在整个商场中的排名。</p><ul><li><p>源表结构示意</p><table><thead><tr><th align="left">shop_code</th><th align="left">shop_name</th><th align="left">floor_code</th><th align="left">order_date</th><th align="left">order_amount</th><th align="left">market_code</th></tr></thead><tbody><tr><td align="left">HT2021051200025</td><td align="left">BSiEE本涩</td><td align="left">L2</td><td align="left">2022-05-20</td><td align="left">6786</td><td align="left">000035</td></tr><tr><td align="left">HT2021051300007</td><td align="left">ROOKIE</td><td align="left">L3</td><td align="left">2022-05-20</td><td align="left">98887</td><td align="left">000035</td></tr><tr><td align="left">HT2021051300013</td><td align="left">剪花娘子</td><td align="left">L5</td><td align="left">2022-05-20</td><td align="left">4567</td><td align="left">000035</td></tr><tr><td align="left">HT2021051300014</td><td align="left">阿香米线</td><td align="left">L5</td><td align="left">2022-05-20</td><td align="left">5845.23</td><td align="left">000035</td></tr><tr><td align="left">HT2021051700025</td><td align="left">森林鸟</td><td align="left">L2</td><td align="left">2022-05-20</td><td align="left">37463</td><td align="left">000035</td></tr><tr><td align="left">……</td><td align="left">……</td><td align="left">……</td><td align="left">……</td><td align="left">……</td><td align="left">……</td></tr></tbody></table></li><li><p>分别统计每店铺每天的销售额 在所在楼层中的排名、全场中的排名.</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sale.shop_code,</span><br><span class="line">       sale.shop_name ,</span><br><span class="line">       sale.order_date <span class="keyword">as</span> 销售日期 ,</span><br><span class="line">       sale.order_amount <span class="keyword">as</span> 销售额,</span><br><span class="line">       <span class="keyword">rank</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> sale.market_code, sale.order_date <span class="keyword">ORDER</span> <span class="keyword">BY</span> sale.order_amount <span class="keyword">DESC</span>) <span class="keyword">AS</span> 全场范围排名,</span><br><span class="line">       <span class="keyword">rank</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> sale.market_code, sale.floor_code, sale.order_date <span class="keyword">ORDER</span> <span class="keyword">BY</span> sale.order_amount <span class="keyword">DESC</span>) <span class="keyword">AS</span> 店铺在所在楼层中的排名</span><br><span class="line"><span class="keyword">FROM</span> sale_data sale</span><br></pre></td></tr></table></figure></li><li><p>查询结果  (示例)</p><table><thead><tr><th align="left">shop_code</th><th align="left">shop_name</th><th align="left">floor_code</th><th align="left">销售日期</th><th align="left">销售额</th><th align="left">全场范围排名</th><th align="left">店铺在所在楼层中的排名</th></tr></thead><tbody><tr><td align="left">WHDYC(20)Z</td><td align="left">汉黄山</td><td align="left">L5</td><td align="left">2022-05-20</td><td align="left">53038</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">HT2021121300</td><td align="left">老寺黄金</td><td align="left">B1</td><td align="left">2022-05-20</td><td align="left">27799</td><td align="left">2</td><td align="left">1</td></tr><tr><td align="left">HT2021052500</td><td align="left">楚去菜</td><td align="left">L4</td><td align="left">2022-05-20</td><td align="left">21433.41</td><td align="left">3</td><td align="left">1</td></tr><tr><td align="left">HT2021121400</td><td align="left">Cdddoo</td><td align="left">L1</td><td align="left">2022-05-20</td><td align="left">20531</td><td align="left">4</td><td align="left">1</td></tr><tr><td align="left">HT2021052600037</td><td align="left">火瀑麻</td><td align="left">L4</td><td align="left">2022-05-20</td><td align="left">17260</td><td align="left">5</td><td align="left">2</td></tr><tr><td align="left">WHDYC(20)Z</td><td align="left">晓南福</td><td align="left">L4</td><td align="left">2022-05-20</td><td align="left">16358.25</td><td align="left">6</td><td align="left">3</td></tr><tr><td align="left">HT2021080500</td><td align="left">小米家</td><td align="left">L1</td><td align="left">2022-05-20</td><td align="left">13678.03</td><td align="left">7</td><td align="left">2</td></tr><tr><td align="left">……</td><td align="left">……</td><td align="left">……</td><td align="left">……</td><td align="left">……</td><td align="left">……</td><td align="left">……</td></tr></tbody></table></li></ul><h3 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h3><p>聚合类，或者说累加，包括sum、avg、max、count等聚合函数。<br>同样的，如果我们只涉及到一种数据范围的聚合计算，那么只需要正常的聚合语句就可以完成。<br>当你需要同时计算某个值在不同数据范围下的聚合计算，就需要使用窗口函数，比如同时计算某商场每日新增的会员数量，以及截止到当日累计的会员数量。</p><ul><li><p>源数据表结构示意,注册记录表</p><table><thead><tr><th align="left">id</th><th align="left">name</th><th align="left">register_date</th></tr></thead><tbody><tr><td align="left">115752</td><td align="left">李某某</td><td align="left">2022-04-16</td></tr><tr><td align="left">110498</td><td align="left">朱某某</td><td align="left">2022-04-09</td></tr><tr><td align="left">109282</td><td align="left">熊某某</td><td align="left">2022-04-03</td></tr><tr><td align="left">109290</td><td align="left">徐某某</td><td align="left">2022-04-03</td></tr><tr><td align="left">108456</td><td align="left">周某某</td><td align="left">2022-03-28</td></tr><tr><td align="left">107925</td><td align="left">殷某某</td><td align="left">2022-03-24</td></tr><tr><td align="left">107575</td><td align="left">樱某某</td><td align="left">2022-03-20</td></tr><tr><td align="left">107595</td><td align="left">万某某</td><td align="left">2022-03-20</td></tr><tr><td align="left">107597</td><td align="left">郑某某</td><td align="left">2022-03-20</td></tr><tr><td align="left">……</td><td align="left">……</td><td align="left">……</td></tr></tbody></table></li><li><p>统计每日新增会员数及截至当日会员总数</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  m.register_date,</span><br><span class="line">        <span class="keyword">count</span>(<span class="number">0</span>)                                                       <span class="keyword">AS</span> 当日新增会员数,</span><br><span class="line">        <span class="keyword">sum</span>(<span class="keyword">count</span>(<span class="number">0</span>)) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> m.register_date)                  <span class="keyword">AS</span> 截止当日总会员数</span><br><span class="line"> <span class="keyword">FROM</span> bi_data_member m</span><br><span class="line"> <span class="keyword">group</span> <span class="keyword">by</span>  register_date</span><br><span class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> m.register_date <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure></li><li><p>查询结果  (示例)</p><table><thead><tr><th align="left">register_date</th><th align="left">当日新增会员数</th><th align="left">截止当日总会员数</th></tr></thead><tbody><tr><td align="left">2022-05-26</td><td align="left">2</td><td align="left">120092</td></tr><tr><td align="left">2022-05-25</td><td align="left">7</td><td align="left">120090</td></tr><tr><td align="left">2022-05-07</td><td align="left">62</td><td align="left">120083</td></tr><tr><td align="left">2022-05-06</td><td align="left">98</td><td align="left">120021</td></tr><tr><td align="left">2022-05-05</td><td align="left">76</td><td align="left">119923</td></tr><tr><td align="left">2022-05-04</td><td align="left">270</td><td align="left">119847</td></tr><tr><td align="left">2022-05-03</td><td align="left">273</td><td align="left">119577</td></tr><tr><td align="left">2022-05-02</td><td align="left">289</td><td align="left">119304</td></tr><tr><td align="left">2022-05-01</td><td align="left">308</td><td align="left">119015</td></tr><tr><td align="left">……</td><td align="left">……</td><td align="left">……</td></tr></tbody></table></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从窗口函数的结构上看, 它是这么一个结构组成:  <code>fun OVER (PARTITION BY...  ORDER BY...)</code>  </p><ul><li><code>fun</code>表示最终的计算操作函数,可以是窗口函数专用函数,也支持sum、max、avg等通用聚合函数.  </li><li><code>OVER</code> 无实际意义.  </li><li><code>PARTITION BY</code>标识计算的数据范围的划分,也就是分组.  </li><li><code>ORDER BY</code> 这个函数就有意思了,通常概念中它起到排序的作用,比如我们第一个销售排名示例.但大部分情况下,比如我们的会员新统计的示例,他也起到了数据范围圈定的作用.在示例中它的作用是把合计的数据范围截止在当前的日期.</li><li><code>PARTITION BY</code> 和<code>ORDER BY</code>,至少使用其中一个,否则窗口无效.</li></ul><h3 id="其他运用"><a href="#其他运用" class="headerlink" title="其他运用"></a>其他运用</h3><p>移动计算类,除了以上我们提到的示例外,窗口函数还支持移动计算的场景.<br>其实本质上还是数据范围的划定,移动计算的含义就是可以通过指定每一行的前后多少行来聚合计算.而不单单只是根据某些业务字段来分组计算.<br>这种类型我本人尚未在实际业务场景中用到过,所以本文不再赘述.</p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li><p>一些窗口函数</p><table><thead><tr><th align="left">函数名称</th><th align="left">返回类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">row_number()</td><td align="left">bigint</td><td align="left">在其分区中的当前行号，从1开始计算</td></tr><tr><td align="left">rank()</td><td align="left">bigint</td><td align="left">有间隔的当前行排名；与它的第一个相同行的row_number相同</td></tr><tr><td align="left">dense_rank()</td><td align="left">bigint</td><td align="left">没有间隔的当前行排名；这个函数计数对等组</td></tr><tr><td align="left">percent_rank</td><td align="left">double precision</td><td align="left">当前行的相对排名：（rank-1）/(总行数-1)</td></tr><tr><td align="left">cume_dist()</td><td align="left">double precision</td><td align="left">当前行的相对排名：（前面的行数或与当前行相同的行数）/（总行数）</td></tr><tr><td align="left">ntile(num_buckets integer)</td><td align="left">integer</td><td align="left">从1到参数的整数范围，尽可能相等的划分分区</td></tr><tr><td align="left">lag(value any [, offset integer [, default any ]])</td><td align="left">类型同value</td><td align="left">计算分区当前行的前offset行，返回value。如果没有这样的行，返回default替代。offset和default都是当前计算的结果。如果忽略了则offset默认是1，default默认是null</td></tr><tr><td align="left">lead(value any [, offset integer [, default any ]])</td><td align="left">类型同value</td><td align="left">计算分区当前行的后offset行，返回value。如果没有这样的行，返回default替代。offset和default都是当前计算的结果。如果忽略了则offset默认是1，default默认是null</td></tr><tr><td align="left">first_value(value any)</td><td align="left">类型同value</td><td align="left">返回窗口第一行的计算value值</td></tr><tr><td align="left">last_value(value any)</td><td align="left">类型同value</td><td align="left">返回窗口最后一行的计算value值</td></tr><tr><td align="left">nth_value(value any,nth integer)</td><td align="left">类型同value</td><td align="left">返回窗口的第nth行的计算value，从1开始计数，没有符合的行则返回null</td></tr></tbody></table></li><li><p>window子句使用(分组后的再次划分)：</p><table><thead><tr><th align="left">关键字</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">preceding</td><td align="left">往前</td></tr><tr><td align="left">following</td><td align="left">往后</td></tr><tr><td align="left">current row</td><td align="left">当前行</td></tr><tr><td align="left">unbounded</td><td align="left">起点</td></tr><tr><td align="left">unbounded preceding</td><td align="left">表示从前面的起点</td></tr><tr><td align="left">unbounded following</td><td align="left">表示到后面的终点</td></tr></tbody></table></li></ul><p><strong>本文作者</strong>：Lee<br/><strong>本文地址</strong>： <a href="leeblog.icu/2022/05/26/">leeblog.icu/2022/05/26/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC 4.0 BY-NC-SA</a> 许可协议。转载请注明出处！</p>]]></content>
    
    
    <summary type="html">常用的sql语句往往只支持单一的数据范围统计，而窗口函数支持更加灵活更加多样的数据范围划定</summary>
    
    
    
    <category term="技术" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="postgres" scheme="leeblog.icu/tags/postgres/"/>
    
  </entry>
  
  <entry>
    <title>记录一次机房停电后PG故障的解决</title>
    <link href="leeblog.icu/2022/05/24/"/>
    <id>leeblog.icu/2022/05/24/</id>
    <published>2022-05-24T11:25:48.000Z</published>
    <updated>2022-06-02T14:42:39.235Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2022-05-24 11:39:31.957 CST [1] LOG:  listening on IPv4 address &quot;0.0.0.0&quot;, port 5432</span><br><span class="line">2022-05-24 11:39:31.957 CST [1] LOG:  listening on IPv6 address &quot;::&quot;, port 5432</span><br><span class="line">2022-05-24 11:39:31.957 CST [1] LOG:  listening on Unix socket &quot;&#x2F;var&#x2F;run&#x2F;postgresql&#x2F;.s.PGSQL.5432&quot;</span><br><span class="line">2022-05-24 11:39:31.960 CST [24] LOG:  database system was interrupted; last known up at 2022-05-24 07:18:02 CST</span><br><span class="line">2022-05-24 11:39:31.961 CST [24] LOG:  invalid primary checkpoint record</span><br><span class="line">2022-05-24 11:39:31.961 CST [24] PANIC:  could not locate a valid checkpoint record</span><br><span class="line">2022-05-24 11:39:43.952 CST [25] FATAL:  the database system is starting up</span><br><span class="line">2022-05-24 11:39:44.719 CST [26] FATAL:  the database system is starting up</span><br><span class="line">2022-05-24 11:39:45.663 CST [27] FATAL:  the database system is starting up</span><br><span class="line">2022-05-24 11:39:48.726 CST [1] LOG:  startup process (PID 24) was terminated by signal 6: Aborted</span><br><span class="line">2022-05-24 11:39:48.726 CST [1] LOG:  aborting startup due to startup process failure</span><br><span class="line">2022-05-24 11:39:48.898 CST [1] LOG:  database system is shut down</span><br></pre></td></tr></table></figure><h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>测试环境postgreSQL数据库是以docker容器部署的单节点服务，机器在本地机房里。</p><p>昨日凌晨机房又一次突然断电，断电本是机房常事，奈何这次机房服务器再次恢复后pg的容器未能成功重启。</p><p>运维无策，大群求助。我一看这还了得，毕竟辛苦一周的工作成果还在数据库里尚未备份，可不敢怠慢。</p><p>果断出手，连接vpn，登陆服务器。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><ul><li><p><code>docker ps</code> 可以看到，pg的容器还在挣扎着不断启动、失败、启动、失败。<br><code>docker logs -f --tail 200 pg</code> 查看容器启动日志，发现情况还不算严重。应是断电时pg正在进行事务操作，突然断电导致事务日志文件损坏，pg再次启动时读取失败。此时应该只需进入pg容器里重置事务日志即可。<br>然而是容器部署的，容器始终无法启动成功，根本没有下手执行重置的时机。</p><img src="https://s1.ax1x.com/2022/05/26/XEIbo6.png" width="100%">  </li><li><p>这机器的服务部署并非出自我手，为了搞清敌情，<code>docker inspect pg</code>，查看容器详情。<br>通过inspect可以看到，容器的数据存储位置映射了外部的文件位置，而且在环境变量中指定了数据文件存储位置。</p><img src="https://s1.ax1x.com/2022/05/26/XVdvX4.png" width="100%"></li><li><p>当鸡立断，决定启动一个临时容器映射同样的文件存储位置来执行日志重置。</p><ul><li>先是一个<code>docker update --restart=no pg</code>，叫停当前容器的不断重启行为，防止启动临时容器后两个容器同时读写日志文件造成场面进一步的混乱。</li><li>然后基于原来容器的镜像，以临时模式启动一个新容器，并进入容器bash端，切换postgres用户（默认必须以postgres执行），找到rest工具位置全路径，<br> ctrl c ，ctrl v，回车，<img src="https://s1.ax1x.com/2022/05/26/XVwPtx.png" width="100%"><img src="https://s1.ax1x.com/2022/05/26/XVwA1O.png" width="100%"></li></ul></li><li><p>执行成功。退出当前容器，因为是临时的所以退出即运行终止。</p></li><li><p><code>docker start pg</code>  再次启动原来的容器，启动成功。</p></li></ul><p>有惊无险，打完收工，没有备份，下次一定。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>使用到的命令按执行顺序如下:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -a                          <span class="comment">#查看容器列表</span></span><br><span class="line">docker logs -f --tail 200 pg          <span class="comment">#查看pg容器启动日志</span></span><br><span class="line">docker inspect pg                     <span class="comment">#查看容器配置详情</span></span><br><span class="line">docker update --restart=no pg         <span class="comment">#取消失败自动重启</span></span><br><span class="line">docker run -it  -v   /opt/appdata/pgdata:/var/lib/postgresql/data  --env PGDATA=/var/lib/postgresql/data/pgdata  postgres:13   /bin/bash  <span class="comment">##启动临时容器并进入bash</span></span><br><span class="line">su postgres                          <span class="comment">#临时容器内:切换postgres用户</span></span><br><span class="line">pg_resetwal -f /var/lib/postgresql/data/pgdata  <span class="comment">#临时容器内: 利用pg工具，执行事务日志重置</span></span><br><span class="line"><span class="built_in">exit</span>                                 <span class="comment">#临时容器内:退出容器</span></span><br><span class="line">docker start pg                      <span class="comment">#启动pg容器</span></span><br></pre></td></tr></table></figure><p><strong>本文作者</strong>：Lee<br/><strong>本文地址</strong>： <a href="leeblog.icu/2022/05/24/">leeblog.icu/2022/05/24/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC 4.0 BY-NC-SA</a> 许可协议。转载请注明出处！</p>]]></content>
    
    
    <summary type="html">测试环境postgreSQL数据库是以docker容器部署的单节点服务，机器在本地机房里。</summary>
    
    
    
    <category term="技术" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="postgres" scheme="leeblog.icu/tags/postgres/"/>
    
  </entry>
  
  <entry>
    <title>Navicat16 破解（重置试用）</title>
    <link href="leeblog.icu/2022/05/12/"/>
    <id>leeblog.icu/2022/05/12/</id>
    <published>2022-05-12T04:10:05.000Z</published>
    <updated>2022-06-16T14:47:15.107Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-删除Navicat注册表文件"><a href="#1-删除Navicat注册表文件" class="headerlink" title="1.删除Navicat注册表文件"></a>1.删除Navicat注册表文件</h3><p>最简单粗暴的办法是直接备份移除dconf文件。</p><p><code>简单来说，dconf 是一种基于键的配置存储系统，有点类似于 Windows 下的注册表。</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv .config/dconf/user .config/dconf/user_b</span><br></pre></td></tr></table></figure><p>直接移除固然简单，但有可能造成其他软件的一些配置的重置。<br>所以更文雅的做法是编辑他，指定navicat的注册表进行删除重置。<br>dconf文件，可使用dconf命令直接编辑，本文推荐使用各自系统对应的图形编辑器，<br>以作者的arch系统为例，对应图形编辑器是dconf-editor，安装使用即可，其他发行版可自行搜索。</p><p>安装与启动：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S dconf-editor&amp;&amp;dconf-ecditor</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2022/05/12/O0MYuT.png" width="70%">    <p>启动后右键选中重置即可。</p><h3 id="2-删除navicat配置文件or编辑navicat配置文件"><a href="#2-删除navicat配置文件or编辑navicat配置文件" class="headerlink" title="2.删除navicat配置文件or编辑navicat配置文件"></a>2.删除navicat配置文件or编辑navicat配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -rf ~/.config/navicat/Premium/preferences.json</span><br></pre></td></tr></table></figure><p>不过该方法会直接把原本本地配置的链接或密码删除，打开navicat后需要重新配置链接。<br>所以这里可以编辑preferences.json文件，删除json的第一个hash码字段即可。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>通过学习dconf文件的编辑。我们可以解锁更多玩法，本文仅供学习交流，有能力请尽快入正。</p><p><strong>本文作者</strong>：Lee<br/><strong>本文地址</strong>： <a href="leeblog.icu/2022/05/12/">leeblog.icu/2022/05/12/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC 4.0 BY-NC-SA</a> 许可协议。转载请注明出处！</p>]]></content>
    
    
    <summary type="html">适用与linux/mac版本重置试用，windows版本可参考</summary>
    
    
    
    <category term="技术" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="工具" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="leeblog.icu/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Idea常用插件及简介</title>
    <link href="leeblog.icu/2022/04/29/"/>
    <id>leeblog.icu/2022/04/29/</id>
    <published>2022-04-29T11:25:48.000Z</published>
    <updated>2022-05-12T06:49:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NO-1"><a href="#NO-1" class="headerlink" title="NO.1"></a>NO.1</h2><p><strong>Translation</strong><code>翻译插件</code></p><p>故名思义，Translation是一款翻译插件。支持<code>自定义翻译引擎</code>、<code>划词翻译</code>，<code>自动翻译</code>。</p><p>选中文字（中文或英文）：<br><code>ctrl</code>+<code>shift</code>+ <code>y</code> 翻译<br><code>ctrl</code>+<code>shift</code>+ <code>x</code> 翻译并选中替换</p><p>同时，可以在插件配置中开启文档自动翻译。</p><p>使用场景，翻译源码注释、翻译log错误信息、起变量名，生产力MAX。</p><h2 id="NO-2"><a href="#NO-2" class="headerlink" title="NO.2"></a>NO.2</h2><p><strong>Alibaba Java Coding Guidelines</strong> <code>代码质量扫描</code>   </p><p>代码质量扫描，根据阿里代码规约标注不符合规范的代码。</p><h2 id="NO-3"><a href="#NO-3" class="headerlink" title="NO.3"></a>NO.3</h2><p><strong>MybatisX</strong> <code>Mybatis框架辅助插件</code>   </p><p>Mapper接口和XML实现可以来回跳转，也可以直接生成对应xml标签，mapper和xml支持自动提示，如jpa(参考MybatisCodeHelperPro)。</p><h2 id="NO-4"><a href="#NO-4" class="headerlink" title="NO.4"></a>NO.4</h2><p><strong>GitToolBox</strong> <code>git辅助插件</code>   </p><p>自动检查更新仓库代码,代码行级展示提交信息，提交通知、延迟通知等。</p><p><strong>本文作者</strong>：Lee<br/><strong>本文地址</strong>： <a href="leeblog.icu/2022/04/29/">leeblog.icu/2022/04/29/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC 4.0 BY-NC-SA</a> 许可协议。转载请注明出处！</p>]]></content>
    
    
    <summary type="html">工具即生产力！插件即生产力！</summary>
    
    
    
    <category term="技术" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="工具" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="leeblog.icu/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="插件" scheme="leeblog.icu/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Jetbrains旗下所有产品激活方法</title>
    <link href="leeblog.icu/2022/04/26/"/>
    <id>leeblog.icu/2022/04/26/</id>
    <published>2022-04-26T08:59:33.000Z</published>
    <updated>2022-05-12T03:51:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在网络注册码乱象丛生的今天，我们再难以像以前那样找到稳定可用的方法了。</p></blockquote><blockquote><p>随着 <a href="https://zhile.io/">知了大佬</a> 的出现，我们终于看到了白嫖的曙光————无限试用插件<a href="https://zhile.io/2020/11/18/jetbrains-eval-reset-deprecated.html"><code>IDE Eval Reset</code></a>。</p></blockquote><blockquote><p>然而，Jetbrains道高一尺，随着idea<code>2021.2.3</code>版本的推出，我们含泪挥别<a href="https://zhile.io/2020/11/18/jetbrains-eval-reset-deprecated.html"><code>IDE Eval Reset</code></a></p></blockquote><blockquote><p>可是，知了大佬技艺日渐精进，魔高一丈，最终祭出大杀器————<a href="https://zhile.io/2021/11/29/ja-netfilter-javaagent-lib.html">ja-netfilter</a> !!!</p></blockquote><blockquote><p>接下来，本文将带大家一起见证它的牛逼。。。。 </p></blockquote><blockquote><p>最后，本文只做个人学习研究之用，不得用于商业用途！<br>建议<a href="https://www.jetbrains.com/idea/buy/#commercial">点击链接</a> 购买正版</p></blockquote><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li><p>官方下载相关产品（推荐下载 <a href="https://www.jetbrains.com/toolbox-app/">ToolBox</a> 进行相关产品安装，便于后期软件及软件管理升级）</p> <img src="https://s1.ax1x.com/2022/04/27/LLSuTS.png" width="50%"> </li><li><p>访问<a href="https://jetbra.in/s">https://jetbra.in/s</a> 下载 <a href="https://jetbra.in/files/ja-netfilter-all-7d68b53deb1b1a16f8e95ecf8f3f98805d18368d.zip">ja-netfilter-all.zip</a></p></li><li><p>解压ja-netfilter-all.zip</p></li></ul><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><blockquote><p>两种进行路径。</p></blockquote><h4 id="第一种："><a href="#第一种：" class="headerlink" title="第一种："></a>第一种：</h4><ol><li><p>通过注册帐号并登陆进入试用期，打开idea。或在<a href="https://www.ajihuo.com/idea/4222.html">https://www.ajihuo.com/idea/4222.html</a> 该站获取激活码，打开idea。</p></li><li><p>打开idea菜单<code>Help</code>-&gt;<code>Edite Custom VM Options...</code>,对idea启动脚本进行编辑，在文件下面添加一行:</p><p><code>-javaagent:/你/的/路/径/ja-netfilter-all/ja-netfilter.jar</code></p><p>如图：</p><img src="https://s1.ax1x.com/2022/04/27/LLCcmq.png" width="100%">  </li></ol><ol start="3"><li>重启idea，在 <a href="https://jetbra.in/s">https://jetbra.in/s</a> 复制对应的激活码，输入注册码，激活成功。</li></ol><hr><h4 id="第二种-该方法不一定能成功"><a href="#第二种-该方法不一定能成功" class="headerlink" title="第二种 该方法不一定能成功"></a>第二种 <code>该方法不一定能成功</code></h4><ol><li>进入文件夹ja-netfilter-all/scripts/，执行系统对应的脚本(windows执行.vbs后缀的,mac及linux执行.sh后缀的)。</li><li>启动idea,在<a href="https://jetbra.in/s">https://jetbra.in/s</a>复制对应的激活码，输入注册码，激活成功。</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>编辑<code>~/ja-netfilter-all/config/mymap.conf</code>可随意修改到期时间及licenseeName。</li><li>该软件适用所有插件</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><ul><li>再次致谢知了<a href="https://zhile.io/">https://zhile.io/</a></li></ul><p><strong>本文作者</strong>：Lee<br/><strong>本文地址</strong>： <a href="leeblog.icu/2022/04/26/">leeblog.icu/2022/04/26/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC 4.0 BY-NC-SA</a> 许可协议。转载请注明出处！</p>]]></content>
    
    
    <summary type="html">在网络注册码乱象丛生的今天，我们再难以像以前那样找到稳定可用的方法了</summary>
    
    
    
    <category term="技术" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="工具" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="leeblog.icu/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="idea" scheme="leeblog.icu/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>优秀开源项目之Shift-etl,从此告别无意义加班</title>
    <link href="leeblog.icu/2020/10/10/"/>
    <id>leeblog.icu/2020/10/10/</id>
    <published>2020-10-10T12:21:48.000Z</published>
    <updated>2022-05-13T03:03:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是一个简单轻量的ETL(Extract-Transform-Load)工具，简单到您花5到10分钟的时间读完这篇文章便可以了然它的使用方法，如果你有数据接口对接的业务场景，你可以参考它。<br>它会以数据库配置的方式，帮助你实现数据接口对接，减少重复编码的工作量，同时可以随时灵活调整、降低后续业务调整带来的影响。</p><p>它的核心代码只有三页,分别是<a href="https://github.com/Solo8World/shift-etl/blob/master/src/main/java/com/example/api/service/EtlExtractService.java">EtlExtractService</a> (数据抽取类)、<a href="https://github.com/Solo8World/shift-etl/blob/master/src/main/java/com/example/api/service/EtlProcessService.java">EtlProcessService</a> (数据处理类)、<a href="https://github.com/Solo8World/shift-etl/blob/master/src/main/java/com/example/api/service/EtlLoadService.java">EtlLoadService</a> (数据加载类)；</p><p>然后这是它的github地址：<a href="https://github.com/Solo8World/shift-etl">https://github.com/Solo8World/shift-etl</a>  </p><h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><p>数据抽取(Extract) -&gt; 数据处理(Transform) -&gt; 数据加载(Load)</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>java 1.8+</li><li>mysql5.6+</li></ul><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p> “以下均为示例，作者很狗的找了个百度文库的接口来作请求”</p><h3 id="一句需求"><a href="#一句需求" class="headerlink" title="一句需求"></a>一句需求</h3><blockquote><p>对接百度文库接口将返回书籍数据存入本地表demo_wenku_book中。  </p></blockquote><p>接口数据结构示例：<br><img src="https://s1.ax1x.com/2020/10/10/0szB8O.png" width="150%"></p><p>目标表表结构<br><img src="https://s1.ax1x.com/2020/10/10/0yDp5D.png" width="150%"> </p><h3 id="三步实现"><a href="#三步实现" class="headerlink" title="三步实现"></a>三步实现</h3><p><strong>1.将接口信息录入etl_source表</strong><br><img src="https://s1.ax1x.com/2020/10/10/06nw4S.png" width="300%">  </p><p>   etl_source表字段意义解释：  </p><p>   <code>source_key</code>：一个数据同步任务的自定义标识，后面调用etl执行同步时会需要传入此标识  </p><p>   <code>source_url</code>：接口全路径，支持https调用  </p><p>   <code>request_method</code>：接口请求方式，‘GET’，‘post’等，不区分大小写   </p><p>   <code>content_type</code>：接口传参类型，支持0:form、1:json、2:urlencoded传参  </p><p>   <code>process_method</code>：接口数据处理方式，支持0:同步处理(同步进入数据处理及加载逻辑),1:异步处理(异步进入数据处理及加载逻辑),2:自定义处理(不进入数据处理及加载逻辑)  </p><p>   <code>remark</code>： 自定义备注</p><p><strong>2.将数据处理规则录入etl_data_process_rule表</strong><br><img src="https://s1.ax1x.com/2020/10/10/06uA58.png" width="150%">    </p><p>   etl_data_process_rule表字段意义解释：  </p><p>   <code>source_key</code>:一个数据同步任务的自定义标识,同我们第一步中自定义的标识  </p><p>   <code>data_key</code>:源数据json结构中字段位置，<code>data.list[].show_doc_id</code> 中，<code>[]</code>标识为数组  </p><p>   <code>has_mapping</code>:当前示例需求中并不需要，该字段含义是<code>是否需要联查当前数据库中其他字段值来替换</code>，它应用的业务场景如：我们现有一张书籍分类表，源数据结构给了一个书籍分类字段”哲学”，而我们需要转换成分类表对应id并给demo_wenku_book存入。  </p><p>   <code>mapping_id</code>:当前示例需求中并不需要，业务场景同上，该字段用于指定联查操作（etl_data_process_mapping） </p><p>   <code>has_distinct</code>:是否需以此字段进行数据去重 </p><p>   <code>target_table</code>:对应存入表表名，该示例需求下为demo_wenku_book   </p><p>   <code>target_columns</code>:对应存入表字段字段名   </p><p>   <code>default_value</code>:源数据字段值为空时的默认值，无默认值为null</p><p>   <code>exec_sort</code>:该示例需求中并不需要，一个数据同步任务下支持多次数据处理操作，该字段指定了数据处理的执行顺序。业务场景如：先将源数据的书籍分类信息去重存入分类表，再将源数据的书籍信息存入书籍表   </p><p>   <code>exec_type</code>:数据处理后的加载操作类型，支持<code>insert</code>(新增),<code>replace</code>(替换),<code>update</code>(修改),<code>delete</code>(删除),<code>insert or update</code>(根据条件动态新增或修改),<code>java</code>(执行一段java函数)  </p><p>   <code>is_condition</code>:该示例需求中并不需要，该字段的意义是<code>是否为条件字段</code>，条件字段应用于<code>update</code>、<code>delete</code>、<code>insert or update</code>操作类型。  </p><p>   <code>condition_symbol</code>:该示例需求中并不需要，该字段的意义是<code>条件字段的比较符</code>，支持 <code>=``&lt;``&lt;=</code>。当操作类型为<code>java</code>时，该字段用于指明java函数的入参类型(String/Integer)  </p><p>   <code>remark</code>:自定义备注  </p><p><strong>3.调用EtlExtractService.executorClient执行数据同步</strong>  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">executorClient</span><span class="params">(<span class="meta">@NotNull</span> String sourceKey,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Map&lt;String, Object&gt; param,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Map&lt;String, String&gt; header)</span></span>;  </span><br></pre></td></tr></table></figure><p>方法参数:<br> <code>sourceKey</code>:一个数据同步任务的自定义标识<br> <code>param</code>:该示例需求中并不需要，接口请求参数，这个其实也可以做成动态自定义而无需硬编码的,看实际需求业务场景<br> <code>header</code>:该示例需求中并不需要，接口请求头部信息，同上  </p><p>所以该示例需求下这么调用一下：  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">etlExtractService.executorClient(<span class="string">&quot;wenku-book&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">0</span>),<span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>啊哦，肝到这里出了几个问题：<br>1.项目启动数据库一直连接不上，时区问题驱动版本问题都排查了个遍，最终在application配置文件上找到了原因：我们项目用的yml格式文件，而yml对小数点的解析有问题，而我嫖阿里的rds密码正好就有一个小数点，害，yml改不了俺改。<br>2.demo表忘记加主键自增了，这个倒没花啥时间<br>3.<code>Data too long for column &#39;summary&#39; at row 2</code>，源数据返回的书籍简介超长了，问题不大，加大加长demo表对应字段的长度</p><p>ok继续<br><strong>有了</strong>：<br><img src="https://s1.ax1x.com/2020/10/10/0yRfKg.png" width="150%"><br>(看来大家都有一个发财梦)</p><p>与此同时我们的<code>etl_source_data</code>表中也多了一条数据，嗯是两条：<br><img src="https://s1.ax1x.com/2020/10/10/0yWgoR.png" width="150%"><br>第一条是一条因为数据过长加载失败的记录。第二条最后成功加载的记录。</p><p>   etl_source_data表字段意义解释：<br>   <code>source_key</code>:一个数据同步任务的自定义标识,无需赘述<br>   <code>source_data</code>:同步回来的源数据<br>   <code>processing_status</code>:数据处理/加载状态0-未处理1-处理中,2-处理完成 3-处理失败<br>   <code>action_date</code>:开始处理时间<br>   <code>process_time</code>:处理及加载耗时(毫秒)，我这里网络不好所以耗时较长，正常百毫秒<br>   <code>process_result</code>:处理结果，处理状态失败的话这里会保存错误信息，便于排查  </p><blockquote><p>以上，啰嗦那么多其实操作就简单三步</p></blockquote><hr><h2 id="高（fu）级（za）进（yi）阶（dian）"><a href="#高（fu）级（za）进（yi）阶（dian）" class="headerlink" title="高（fu）级（za）进（yi）阶（dian）"></a>高（fu）级（za）进（yi）阶（dian）</h2><blockquote><p>shift etl能做到的不止如此，更多玩法明天再写，溜了。。。</p></blockquote><p>ps：调用代码俺写在了test目录下,可以搞下来自己试运行.实际业务场景下大多是以定时器定时触发同步任务，而同步任务动态参数逻辑可以在定时任务中实现</p><p>再ps：这个其实是俺自己写的项目，所以这篇bolg的标题那么优秀</p><p><strong>本文作者</strong>：Lee<br/><strong>本文地址</strong>： <a href="leeblog.icu/2020/10/10/">leeblog.icu/2020/10/10/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC 4.0 BY-NC-SA</a> 许可协议。转载请注明出处！</p>]]></content>
    
    
    <summary type="html">这是一个相对简陋也非常轻量的ETL(Extract-Transform-Load)工具，如果你有数据接口对接的业务场景，你可以参考它。</summary>
    
    
    
    <category term="技术" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="代码" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/%E4%BB%A3%E7%A0%81/"/>
    
    
    <category term="java" scheme="leeblog.icu/tags/java/"/>
    
    <category term="开源" scheme="leeblog.icu/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>idea插件git commit template的使用与changeLog的生成</title>
    <link href="leeblog.icu/2020/09/13/"/>
    <id>leeblog.icu/2020/09/13/</id>
    <published>2020-09-13T11:00:34.000Z</published>
    <updated>2022-04-29T01:39:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>git commit template 该插件是为了规范git提交注释的。一个项目一个团队的git log一定要整整齐齐的。<br>统一的提交注释规范，除了自己赏心悦目获得极大的舒适感以外，还能为后续的code review、版本升级change log文档的生成，提供极大的便利。  </p><ul><li><strong><a href="https://github.com/angular/angular/blob/master/CONTRIBUTING.md#-commit-message-guidelines">Angular规范</a> 提交格式如下：</strong></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>(<span class="tag">&lt;<span class="name">scope</span>&gt;</span>): <span class="tag">&lt;<span class="name">subject</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BLANK</span> <span class="attr">LINE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BLANK</span> <span class="attr">LINE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>含义：</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">提交类型(改动涉及范围): 简要描述</span><br><span class="line"><span class="tag">&lt;<span class="name">空行</span>&gt;</span></span><br><span class="line">详细描述(可换多行进行描述)</span><br><span class="line"><span class="tag">&lt;<span class="name">空行</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">页脚</span>&gt;</span>（BREAKING CHANGE重大改动描述；Close Issue）</span><br></pre></td></tr></table></figure></li><li><p><strong>提交类型：</strong></p><ul><li>feat：新功能开发</li><li>fix：bug修复</li><li>docs：项目文档改动</li><li>style： 代码格式（不影响代码运行的变动,空格,格式化,等等）</li><li>refactor：重构（理论上不影响功能的代码重构）</li><li>perf: 性能优化</li><li>test：增加或者修改测试</li><li>build: 影响构建系统或外部依赖项的更改(maven)</li><li>ci: 对CI配置文件和脚本的更改</li><li>chore：对非 src 和 test 目录的修改</li><li>revert: 还原上一次提交</li></ul></li></ul><ul><li><p><strong>以feat提交为例，commit message格式如下:</strong></p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="attribute">feat(系统管理)</span>: 新增用户密码设置规则检验  </span><br><span class="line"></span><br><span class="line">(1)验证密码设置由大小写字母数字特殊符号任意三种组合</span><br><span class="line">(2)验证密码设置长度8-12位</span><br></pre></td></tr></table></figure></li><li><p>注：</p><ul><li>提交格式中<code>type</code> 、<code>subject</code>为必填，<code>scope</code>、<code>body</code> 、<code>footer</code>为选填 </li><li>revert提交时以revert:开头, 后面跟着被撤销Commit的Header。<br>Body部分的格式是固定的，必须写成This reverts commit <hash>,<br>其中的hash是被撤销 commit 的 SHA 标识符.</li></ul></li></ul><h2 id="Git-Commit-Template插件的安装与使用"><a href="#Git-Commit-Template插件的安装与使用" class="headerlink" title="Git Commit Template插件的安装与使用"></a><code>Git Commit Template</code>插件的安装与使用</h2><ul><li><strong>安装</strong>  </li></ul><p>idea中直接<code>File</code>-&gt;<code>Setting</code>-&gt;<code>Plugins</code>搜索安装即可<br><img src="https://s1.ax1x.com/2020/09/16/wcTUMQ.png" width="100%"></p><ul><li><strong>使用</strong>  </li></ul><ol><li><p>安装并重启idea后，操作提交时会有此按钮  </p><img src="https://s1.ax1x.com/2020/09/16/wcT2M4.png" width="100%"></li><li><p>点击弹出  </p><img src="https://s1.ax1x.com/2020/09/16/wcTHzD.png" width="100%"></li><li><p>按需填写并确认后生成以下格式：  </p><img src="https://s1.ax1x.com/2020/09/16/wcTjeA.png" width="100%"></li></ol><h2 id="利用conventional-changelog生成Change-log"><a href="#利用conventional-changelog生成Change-log" class="headerlink" title="利用conventional-changelog生成Change log"></a>利用conventional-changelog生成Change log</h2><ul><li><strong>安装</strong><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g conventional-changelog-cli</span><br></pre></td></tr></table></figure></li><li><strong>生成</strong><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conventional-changelog -p angular -i CHANGELOG.md -s</span><br></pre></td></tr></table></figure></li><li><strong>生成的md效果如下</strong>  </li></ul>  <img src="https://s1.ax1x.com/2020/09/16/wc7NY6.png" width="100%"><h2 id="更多可参考"><a href="#更多可参考" class="headerlink" title="更多可参考:"></a>更多可参考:</h2><p><a href="https://www.cnblogs.com/daysme/p/7722474.html">Git 提交的正确姿势：Commit message 编写指南</a><br><a href="https://blog.csdn.net/itguangit/article/details/99590995#t2">IDEA 中 Git Commit message 编写</a><br><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">Commit message 和 Change log 编写指南</a>  </p><p><strong>本文作者</strong>：Lee<br/><strong>本文地址</strong>： <a href="leeblog.icu/2020/09/13/">leeblog.icu/2020/09/13/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC 4.0 BY-NC-SA</a> 许可协议。转载请注明出处！</p>]]></content>
    
    
    <summary type="html">一个项目一个团队的git log一定要整整齐齐的。统一的提交注释规范，除了自己赏心悦目获得极大的舒适感以外，还能为后续的code review、版本升级change log文档的生成，提供极大的便利。</summary>
    
    
    
    <category term="技术" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="工具" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="GIT" scheme="leeblog.icu/tags/GIT/"/>
    
    <category term="开发规范" scheme="leeblog.icu/tags/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    
    <category term="工具" scheme="leeblog.icu/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>GIT Flow流程管理规范</title>
    <link href="leeblog.icu/2020/09/10/"/>
    <id>leeblog.icu/2020/09/10/</id>
    <published>2020-09-10T08:59:33.000Z</published>
    <updated>2020-10-15T14:16:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><blockquote><p>Git Flow Integration插件是基于git flow(开发流程管理模型)的idea插件。  </p></blockquote><p>git flow开发流程管理模型主要使用五类分支：  </p><ul><li>master 主分支:生产环境部署分支, master分支永远与生产环境部署的版本保持同步。  </li><li>develop 开发分支:永远是下一个版本中已开发完成的新特性的最新代码。 </li><li>feature/功能名称: 新功能开发分支,为具体某一新功能开发而存在的临时分支,开发完成后合并回develop分支,并删除。 </li><li>release/版本号:预上线分支,版本中所有功能开发完毕并合并到develop以后,从develop开出release分支进行整体测试，测试稳定后打上tag同时并入develop、master分支。  </li><li>hotfix/bug:生产环境bug修复分支,修复后双向合并到develop和master。   </li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h2><ul><li>Git Flow Integration依赖于本地git flow，所以先安装git flow软件包:  <blockquote><p>执行<code>git flow version</code> 检查是否已安装</p></blockquote><ul><li>Ubuntu or Debian安装<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install git-flow </span><br></pre></td></tr></table></figure></li><li>Archlinux 安装<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yaourt -S gitflow-avh </span><br></pre></td></tr></table></figure></li><li>Windows安装<br>请参考 <a href="https://juejin.im/post/6844903682027307022">Windows下gitflow的安装方法</a>  </li></ul></li><li>安装Idea插件<br>idea中<code>File</code>-&gt;<code>Setting</code>-&gt;<code>Plugins</code>搜索安装即可  <img src="https://s1.ax1x.com/2020/09/16/wc7rmd.png" width="100%">  </li></ul><h2 id="插件使用"><a href="#插件使用" class="headerlink" title="插件使用"></a><strong>插件使用</strong></h2><ol><li><p>安装并重启idea后,右下角出现<code>No Gitflow</code>  </p>  <img src="https://s1.ax1x.com/2020/09/16/wc7Imj.png" width="100%"></li><li><p>点击init repo进行初始化<br><em>注：git flow init之前请确保本地没有尚未提交的更改</em>  </p><img src="https://s1.ax1x.com/2020/09/16/wc7jcF.png" width="100%"></li><li><p>确认后git flow自动基于master创建并切换到develop分支，并在右下角gitflow中出现操作选项    </p><img src="https://s1.ax1x.com/2020/09/16/wcHp7R.png" width="100%"> <figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>新功能开发分支线（feature）</span><br><span class="line"><span class="bullet">* </span>开发版本bug修复线（bugfix）</span><br><span class="line"><span class="bullet">* </span>新版本发布线/预上线（release）</span><br><span class="line"><span class="bullet">* </span>生产版本bug修复线（hotfix）</span><br></pre></td></tr></table></figure></li><li><p>开始使用，开发系统管理模块  </p><img src="https://s1.ax1x.com/2020/09/16/wcHVje.png" width="100%"></li><li><p>确认后自动生成feature为前缀的开发分支，并提供以下操作  </p><img src="https://s1.ax1x.com/2020/09/16/wcHQ4P.jpg" width="70%"></li></ol><p><code>Finish feature</code> 结束分支：合并当前开发分支至develop并删除当前开发分支<br><code>Publish feature</code>推送分支至远程仓库</p><h2 id="扩-分支管理详细"><a href="#扩-分支管理详细" class="headerlink" title="扩:分支管理详细"></a>扩:分支管理详细</h2><ul><li>master<ul><li>主分支, 随项目一直存在的长期分支.</li><li>master分支HEAD所在的位置, 永远是当前生产环境的代码.</li><li>master分支不允许直接提交代码, 仅允许从release或者hotfix分支通过merge request合并代码.</li></ul></li><li>develop<ul><li>开发分支, 随项目一直存在的长期分支.</li><li>develop分支的HEAD所在的位置, 永远是下一个版本中已开发完成的新特性的最新代码.</li><li>develop分支的代码每天自动构建并部署到测试环境.</li><li>develop分支不允许直接提交代码, 仅允许从feature, release或者hotfix分支通过merge request合并代码.</li><li>当develop分支中下一个版本的新特性已经全部开发完毕后, 从develop分支开出release分支, 进入测试阶段.</li><li>在下个版本的release分支创建之前, 非下个版本的feature分支不允许向develop分支合并.</li></ul></li><li>feature分支<ul><li>feature分支是一类以feature/为前缀(gitflow默认值, 可以更换)的分支的统称.</li><li>每一个feature分支从develop分支新建, 进行<strong>某一个功能</strong>的开发. 功能开发并测试稳定后, feature分支将合并回develop分支.</li><li>同一个人可以同时开发多个feature分支, 同一个feature分支也可以同时被多个人开发.</li><li>多个feature同时开发的情形, 后开发完的分支在最后合并回develop时, 往往会遇到冲突的情况. 此时一般遵循一下两种方法解决冲突.<ul><li>先将最新的develop分支向当前feature分支进行合并, 然后再将当前feature分支合并回develop.</li><li>先将当前的feature分支向最新的develop分支进行rebase, 然后再将当前feature分支合并回develop.</li><li>两种方式的比较, 可以参考文章Merging vs. Rebasing, 或其中文版代码合并：Merge、Rebase 的选择</li></ul></li></ul></li><li>release分支<ul><li>release分支是一类以release/为前缀(gitflow默认值, 可以更换)的分支的统称.</li><li>develop分支上的下一个版本的所有新特性开发完毕, 从develop分支开出一个该版本的release分支, 并进行测试.</li><li>release分支不允许进行新特性开发, 而只进行bug修复和更新版本mata信息(如版本号, 构建日期, 更新日志等), 并且可以不定期将新的bug修复改动合并回develop.</li><li>当release充分测试稳定后, 同时合并进入master分支和develop分支, 并在master分支上的建议该release版本的TAG.</li></ul></li><li>hotfix分支<ul><li>当生产环境发现紧急bug时，可以通过新建hotfix分支，来修复bug, 修复后双向合并到develop和master.  </li></ul></li></ul><h2 id="更多可参考"><a href="#更多可参考" class="headerlink" title="更多可参考:"></a>更多可参考:</h2><p><a href="https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/git-flow">git-flow 的工作流程| Learn Version Control with Git</a><br><a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html">Git 工作流程- 阮一峰的网络日志</a><br><a href="https://zhuanlan.zhihu.com/p/153459671">git flow使用规范</a></p><p><strong>本文作者</strong>：Lee<br/><strong>本文地址</strong>： <a href="leeblog.icu/2020/09/10/">leeblog.icu/2020/09/10/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC 4.0 BY-NC-SA</a> 许可协议。转载请注明出处！</p>]]></content>
    
    
    <summary type="html">Git Flow Integration插件是基于git flow(开发流程管理模型)的idea插件。</summary>
    
    
    
    <category term="技术" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="GIT" scheme="leeblog.icu/tags/GIT/"/>
    
    <category term="开发规范" scheme="leeblog.icu/tags/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法与Pandoc转换</title>
    <link href="leeblog.icu/2020/09/08/"/>
    <id>leeblog.icu/2020/09/08/</id>
    <published>2020-09-08T09:02:59.000Z</published>
    <updated>2022-04-28T02:18:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言： markdown极简主义标记语言，能帮我们进行便捷的文字排版，文档写作居家必备。<br>语法比较简单，本文不再作过多赘述。重点是pandoc，pandoc是约翰麦克法兰（一位伯克利哲学系的教授）开发的一个文本转换工具，<br>能帮我们将md文件转换为word、pdf、html，甚至ppt，当然，不止如此，你能想到的它都可以做到，号称文档转换界的瑞士军刀。</p></blockquote><h1 id="文本标记语言-Markdown"><a href="#文本标记语言-Markdown" class="headerlink" title="文本标记语言 Markdown"></a>文本标记语言 <code>Markdown</code></h1><blockquote><p>最流行的轻量<a href="https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/5964436?fr=aladdin">文本标记语言</a></p></blockquote><h2 id="常用语法："><a href="#常用语法：" class="headerlink" title="常用语法："></a>常用语法：</h2><img src="https://s1.ax1x.com/2020/09/16/wcHHDH.png" width="100%"><h2 id="更多请参考"><a href="#更多请参考" class="headerlink" title="更多请参考"></a>更多请参考</h2><p><a href="https://www.runoob.com/markdown/md-tutorial.html">Markdown 教程| 菜鸟教程</a></p><hr><h1 id="标记语言转换工具Pandoc"><a href="#标记语言转换工具Pandoc" class="headerlink" title="标记语言转换工具Pandoc"></a>标记语言转换工具<code>Pandoc</code></h1><ul><li><p><strong>简介</strong> </p><blockquote><p><a href="https://pandoc.org/">Pandoc</a> 是由<a href="https://johnmacfarlane.net/macfarlane-cv.html">John MacFarlane</a> 开发的标记语言转换工具，可实现不同标记语言间的格式转换，堪称该领域中的“瑞士军刀”。  </p></blockquote><img src="https://s1.ax1x.com/2020/09/16/wcbFVs.jpg" width="10%"> </li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h2><ul><li>点击进入二进制包<a href="https://github.com/jgm/pandoc/releases/tag/2.10.1">下载页面</a> 选取对应包下载安装即可  </li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h2><ul><li><p>markdown转word  </p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">pandoc</span> <span class="selector-tag">git-extend</span><span class="selector-class">.md</span>  <span class="selector-tag">-o</span> <span class="selector-tag">md_convert_doc</span><span class="selector-class">.docx</span></span><br></pre></td></tr></table></figure></li><li><p>markdown转html</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">pandoc</span> <span class="selector-tag">git-extend</span><span class="selector-class">.md</span>  <span class="selector-tag">-o</span> <span class="selector-tag">md_convert_html</span><span class="selector-class">.html</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>本文作者</strong>：Lee<br/><strong>本文地址</strong>： <a href="leeblog.icu/2020/09/08/">leeblog.icu/2020/09/08/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC 4.0 BY-NC-SA</a> 许可协议。转载请注明出处！</p>]]></content>
    
    
    <summary type="html">markdown极简主义标记语言，能帮我们进行便捷的文字排版，文档写作居家必备。pandoc是约翰麦克法兰（一位伯克利哲学系的教授）开发的一个文本转换工具</summary>
    
    
    
    <category term="技术" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="工具" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="leeblog.icu/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="文档" scheme="leeblog.icu/tags/%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>Maven插件之git-commit-id</title>
    <link href="leeblog.icu/2020/09/05/"/>
    <id>leeblog.icu/2020/09/05/</id>
    <published>2020-09-05T09:00:58.000Z</published>
    <updated>2022-04-28T02:18:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Maven插件-git-commit-id-plugin"><a href="#Maven插件-git-commit-id-plugin" class="headerlink" title="Maven插件 git-commit-id-plugin"></a>Maven插件 <code>git-commit-id-plugin</code></h1><blockquote><p>让我们通过接口就晓得后台代码的版本。    </p></blockquote><p>该插件会在源码编译打包时生成git版本信息、打包信息，便于后期运维。</p><h2 id="git-commit-id-plugin-使用"><a href="#git-commit-id-plugin-使用" class="headerlink" title="git-commit-id-plugin 使用"></a><a href="https://github.com/git-commit-id/git-commit-id-maven-plugin">git-commit-id-plugin</a> 使用</h2><ul><li><p>pom文件引入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>pl.project13.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>git-commit-id-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">generateGitPropertiesFile</span>&gt;</span>true<span class="tag">&lt;/<span class="name">generateGitPropertiesFile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">injectAllReactorProjects</span>&gt;</span>true<span class="tag">&lt;/<span class="name">injectAllReactorProjects</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>重新打包，jar包中自动生成<code>git.properties</code>文件，如下：  </p><img src="https://s1.ax1x.com/2020/09/16/wcHBCV.png" width="100%"></li><li><p>编写项目版本信息查询接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> GitProperties gitProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/version&quot;)</span></span><br><span class="line"><span class="function">HashMap&lt;String, String&gt; <span class="title">version</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, String&gt; versionInfo = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">    versionInfo.put(<span class="string">&quot;branch&quot;</span>, gitProperties.getBranch());</span><br><span class="line">    versionInfo.put(<span class="string">&quot;commitId&quot;</span>, gitProperties.getCommitId());</span><br><span class="line">    versionInfo.put(<span class="string">&quot;commitMessage&quot;</span>, gitProperties.get(<span class="string">&quot;commit.message.full&quot;</span>));</span><br><span class="line">    versionInfo.put(<span class="string">&quot;commitUser&quot;</span>, gitProperties.get(<span class="string">&quot;commit.user.name&quot;</span>));</span><br><span class="line">    versionInfo.put(<span class="string">&quot;commitTime&quot;</span>, DateUtil.date(Long.parseLong(gitProperties.get(<span class="string">&quot;commit.time&quot;</span>))).toString());</span><br><span class="line">    versionInfo.put(<span class="string">&quot;buildHost&quot;</span>, gitProperties.get(<span class="string">&quot;build.host&quot;</span>));</span><br><span class="line">    versionInfo.put(<span class="string">&quot;buildUser&quot;</span>, gitProperties.get(<span class="string">&quot;build.user.name&quot;</span>));</span><br><span class="line">    versionInfo.put(<span class="string">&quot;buildTime&quot;</span>, DateUtil.date(Long.parseLong(gitProperties.get(<span class="string">&quot;build.time&quot;</span>))).toString());</span><br><span class="line">    <span class="keyword">return</span>  versionInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>请求接口  </p><img src="https://s1.ax1x.com/2020/09/16/wcHRER.png" width="100%"></li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>springBoot 2.3.0之后的版本无法直接注入GitProperties，<br>需要在启动类声明GitProperties类的Bean属性。</li></ul><h2 id="更多请参考"><a href="#更多请参考" class="headerlink" title="更多请参考"></a>更多请参考</h2><p><a href="https://github.com/git-commit-id/git-commit-id-maven-plugin">该插件的github</a></p><p><strong>本文作者</strong>：Lee<br/><strong>本文地址</strong>： <a href="leeblog.icu/2020/09/05/">leeblog.icu/2020/09/05/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC 4.0 BY-NC-SA</a> 许可协议。转载请注明出处！</p>]]></content>
    
    
    <summary type="html">让我们通过接口就晓得后台代码的版本。该插件会在源码编译打包时生成git版本信息、打包信息，便于后期运维。</summary>
    
    
    
    <category term="技术" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="工具" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="GIT" scheme="leeblog.icu/tags/GIT/"/>
    
  </entry>
  
  <entry>
    <title>Java三页代码之——实现Mysql透明加解密</title>
    <link href="leeblog.icu/2020/08/16/"/>
    <id>leeblog.icu/2020/08/16/</id>
    <published>2020-08-16T07:14:18.000Z</published>
    <updated>2022-04-28T02:04:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间有项目需求做个简单的数据加密，根据开发成本和程序性能综合考虑，<br>最终选定利用mysql加解密函数进行实现。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>项目sql执行前进行拦截，如果包含加密字段则对sql进行字符串截取拼接处理，<br>不同类型不同处理方式：  </p><ul><li>select类型：select字段拼上解密函数及密钥</li><li>insert类型：insert对应字段值拼上加密函数及密钥</li><li>delete类型：对应字段where条件值拼上加密函数及密钥</li><li>update类型：update对应字段值拼上加密字段及密钥，对应字段where条件值拼上加密函数及密钥</li></ul><h2 id="用到的第三方工具包"><a href="#用到的第三方工具包" class="headerlink" title="用到的第三方工具包"></a>用到的第三方工具包</h2><p><a href="https://hutool.cn/">HuTool</a> (一个小而美的java工具包)  </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h2><ul><li><p>配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lee.blog.config.mybatis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lizhuo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//要加密的字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; FIELD = </span><br><span class="line">                  Arrays.asList(<span class="string">&quot;card_no&quot;</span>, <span class="string">&quot;card_key&quot;</span>, <span class="string">&quot;card_private_no&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SALT = <span class="string">&quot;\&quot;bc7a5744-fbf0-5288-c20e-e87ea9ee1ba0\&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ENC_PREFIX = <span class="string">&quot;HEX(ENCODE(&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ENC_SUFFIX = <span class="string">&quot;,&quot;</span> + SALT + <span class="string">&quot;))&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEC_PREFIX = <span class="string">&quot;DECODE(UNHEX(&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEC_SUFFIX = <span class="string">&quot;),&quot;</span> + SALT + <span class="string">&quot;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AS = <span class="string">&quot;AS&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SELECT = <span class="string">&quot;SELECT&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FROM = <span class="string">&quot;FROM&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mybatise拦截类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lee.blog.config.mybatis;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.ReflectUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.executor.statement.RoutingStatementHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.executor.statement.StatementHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.mapping.BoundSql;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.plugin.*;</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.annotations.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lizhuo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Intercepts(&#123;</span></span><br><span class="line"><span class="meta">        @Signature(type = StatementHandler.class, method = &quot;prepare&quot;, args = &#123;Connection.class, Integer.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrepareInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String INSERT = <span class="string">&quot;INSERT&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (invocation.getTarget() <span class="keyword">instanceof</span> RoutingStatementHandler handler) &#123;</span><br><span class="line">            StatementHandler delegate =</span><br><span class="line">                    (StatementHandler) ReflectUtil.getFieldValue(handler, <span class="string">&quot;delegate&quot;</span>);</span><br><span class="line">            BoundSql boundSql = delegate.getBoundSql();</span><br><span class="line">            <span class="keyword">final</span> String sql = boundSql.getSql();</span><br><span class="line">            <span class="keyword">if</span> (needHandler(sql)) &#123;</span><br><span class="line">                handlerSql(boundSql);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlerSql</span><span class="params">(BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//String result = SQLUtils.format(boundSql.getSql(), JdbcConstants.MYSQL);</span></span><br><span class="line">        String sql = replaceSql(boundSql.getSql());</span><br><span class="line">        <span class="keyword">switch</span> (sql.substring(<span class="number">0</span>, <span class="number">6</span>).toUpperCase()) &#123;</span><br><span class="line">            <span class="keyword">case</span> EncConfig.SELECT -&gt; sql = handlerQuerySql(sql);</span><br><span class="line">            <span class="keyword">case</span> INSERT -&gt; sql = handlerInsertSql(sql);</span><br><span class="line">            <span class="keyword">default</span> -&gt; sql = handlerDeleteOrUpdateSql(sql);</span><br><span class="line">        &#125;</span><br><span class="line">        ReflectUtil.setFieldValue(boundSql, <span class="string">&quot;sql&quot;</span>, sql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">handlerDeleteOrUpdateSql</span><span class="params">(String sql)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Sql(sql).toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">handlerQuerySql</span><span class="params">(String sql)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Sql(sql).toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">handlerInsertSql</span><span class="params">(String sql)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;String&gt; insertFiled = Arrays.asList(</span><br><span class="line">                sql.substring(sql.indexOf(<span class="string">&quot;(&quot;</span>) + <span class="number">1</span>, sql.indexOf(<span class="string">&quot;)&quot;</span>)).split(StrUtil.COMMA));</span><br><span class="line">        String insertValueStr = sql.substring(sql.lastIndexOf(<span class="string">&quot;(&quot;</span>) + <span class="number">1</span>, sql.lastIndexOf(<span class="string">&quot;)&quot;</span>));</span><br><span class="line">        List&lt;String&gt; insertValue = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(</span><br><span class="line">                insertValueStr.split(StrUtil.COMMA)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; insertFiled.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> Optional&lt;String&gt; any = EncConfig.FIELD.stream().filter(insertFiled.get(i)::contains).findAny();</span><br><span class="line">            <span class="keyword">if</span> (any.isPresent()) &#123;</span><br><span class="line">                insertValue.set(i, EncConfig.ENC_PREFIX + insertValue.get(i) + EncConfig.ENC_SUFFIX);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> replaceSql(sql, insertValueStr, insertValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">replaceSql</span><span class="params">(String sql, String resourceStr, List&lt;String&gt; targetStrList)</span> </span>&#123;</span><br><span class="line">        AtomicReference&lt;String&gt; targetQueryFiledStr = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        targetStrList.forEach(i -&gt; targetQueryFiledStr.set(</span><br><span class="line">                StringUtils.isBlank(targetQueryFiledStr.get()) ?</span><br><span class="line">                        targetQueryFiledStr + i : targetQueryFiledStr + StrUtil.COMMA + i));</span><br><span class="line">        sql = sql.replace(resourceStr, targetQueryFiledStr.get());</span><br><span class="line">        <span class="keyword">return</span> sql;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">needHandler</span><span class="params">(String sql)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EncConfig.FIELD.stream().anyMatch(sql::contains);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤特殊字符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">replaceSql</span><span class="params">(String sql)</span> </span>&#123;</span><br><span class="line">        sql = sql.replaceAll(<span class="string">&quot;\\n&quot;</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        sql = sql.replaceAll(<span class="string">&quot;\\t&quot;</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sql;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>sql转换类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lee.blog.config.mybatis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.CollectionUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span>  com.lee.blog.config.mybatis.EncConfig.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lizhuo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sql</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String execType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;QueryField&gt; queryField;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String remainder;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sql</span><span class="params">(String sqlStr)</span> </span>&#123;</span><br><span class="line">        StringBuilder sql = <span class="keyword">new</span> StringBuilder(sqlStr);</span><br><span class="line">        <span class="keyword">this</span>.execType = sql.substring(<span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!SELECT.equalsIgnoreCase(execType)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.remainder = sql.substring(<span class="number">6</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> fromIndex = StringUtils.indexOfIgnoreCase(sql, FROM);</span><br><span class="line">        <span class="comment">//解析并赋值对象</span></span><br><span class="line">        String queryFieldStr = sql.substring(<span class="number">6</span>, fromIndex);</span><br><span class="line">        <span class="keyword">boolean</span> has = EncConfig.FIELD.stream().anyMatch(queryFieldStr::contains);</span><br><span class="line">        <span class="keyword">if</span> (has) &#123;</span><br><span class="line">            List&lt;String&gt; queryField = Arrays.asList(queryFieldStr.split(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">            List&lt;QueryField&gt; field = <span class="keyword">new</span> ArrayList&lt;&gt;(queryField.size());</span><br><span class="line">            queryField.forEach(i -&gt; field.add(<span class="keyword">new</span> QueryField(i)));</span><br><span class="line">            <span class="keyword">this</span>.queryField = field;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.queryField = Collections.singletonList(<span class="keyword">new</span> QueryField(queryFieldStr));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.remainder = sql.substring(fromIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sql = <span class="keyword">new</span> StringBuilder(execType);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(queryField)) &#123;</span><br><span class="line">            queryField.forEach(i -&gt; sql.append(i.toString()).append(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">            sql.setCharAt(sql.length() - <span class="number">1</span>, <span class="string">&quot; &quot;</span>.charAt(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        EncConfig.FIELD.forEach(i -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (remainder.contains(i + <span class="string">&quot; = ?&quot;</span>)) &#123;</span><br><span class="line">                remainder = remainder.replace(i + <span class="string">&quot; = ?&quot;</span>,</span><br><span class="line">                        i + <span class="string">&quot; = &quot;</span> + EncConfig.ENC_PREFIX + <span class="string">&quot;?&quot;</span> + EncConfig.ENC_SUFFIX);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (remainder.contains(i + <span class="string">&quot; in&quot;</span>) || remainder.contains(i + <span class="string">&quot; not in&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                String substring = remainder.substring(</span><br><span class="line">                        remainder.indexOf(i + <span class="string">&quot; in (&quot;</span>) + (i + <span class="string">&quot; in (&quot;</span>).length());</span><br><span class="line"></span><br><span class="line">                String valueStr = substring.substring(<span class="number">0</span>, substring.indexOf(<span class="string">&quot;)&quot;</span>));</span><br><span class="line"></span><br><span class="line">                remainder = remainder.replace(valueStr,</span><br><span class="line">                        valueStr.replace(<span class="string">&quot;?&quot;</span>,</span><br><span class="line">                                EncConfig.ENC_PREFIX + <span class="string">&quot;?&quot;</span> + EncConfig.ENC_SUFFIX));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        sql.append(remainder);</span><br><span class="line">        <span class="keyword">return</span> sql.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryField</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String field;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String function;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String alias;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">QueryField</span><span class="params">(String field)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> anyMatch = EncConfig.FIELD.stream().anyMatch(field::contains);</span><br><span class="line">            <span class="keyword">if</span> (!anyMatch) &#123;</span><br><span class="line">                <span class="keyword">this</span>.field = field;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> hasFunction = field.contains(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (hasFunction) &#123;</span><br><span class="line">                <span class="keyword">int</span> lastIndexOfStart = field.lastIndexOf(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> lastIndexOfEnd = field.lastIndexOf(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">                <span class="keyword">this</span>.function = field.substring(<span class="number">0</span>, lastIndexOfStart) + <span class="string">&quot;(@function@)&quot;</span></span><br><span class="line">                        + field.substring(lastIndexOfEnd + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                field = field.substring(lastIndexOfStart + <span class="number">1</span>, lastIndexOfEnd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> hasAlias = StringUtils.containsIgnoreCase(field, AS);</span><br><span class="line">            <span class="keyword">boolean</span> hasPrefix = field.contains(StrUtil.DOT);</span><br><span class="line">            <span class="keyword">if</span> (hasAlias) &#123;</span><br><span class="line">                <span class="keyword">this</span>.alias = field.substring(StringUtils.indexOfIgnoreCase(field, AS) + <span class="number">2</span>);</span><br><span class="line">                field = field.substring(<span class="number">0</span>, StringUtils.indexOfIgnoreCase(field, AS));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.alias = AS + <span class="string">&quot; &quot;</span> + (hasPrefix ?</span><br><span class="line">                        field.substring(field.indexOf(StrUtil.DOT) + <span class="number">1</span>) : field);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.field = field;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> anyMatch = EncConfig.FIELD.stream().anyMatch(field::contains);</span><br><span class="line">            field = anyMatch ? EncConfig.DEC_PREFIX + field + EncConfig.DEC_SUFFIX : field;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> StringUtils.isEmpty(function) ? field + (alias == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : alias)</span><br><span class="line">                    : function.replace(<span class="string">&quot;@function@&quot;</span>, field) + (alias == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><em>ps</em> ：</p><ul><li><p>拦截处理并不支持SELECT * 语句,不建议项目中使用SELECT *； </p></li><li><p>项目中如果没有单独mybatis配置类的话，拦截器默认生效，如果包含配置类则需在配置类中指定开启</p></li></ul><p><strong>本文作者</strong>：Lee<br/><strong>本文地址</strong>： <a href="leeblog.icu/2020/08/16/">leeblog.icu/2020/08/16/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC 4.0 BY-NC-SA</a> 许可协议。转载请注明出处！</p>]]></content>
    
    
    <summary type="html">前段时间有项目需求做个简单的数据加密，根据开发成本和程序性能综合考虑，最终选定利用mysql加解密函数进行实现。</summary>
    
    
    
    <category term="技术" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="代码" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/%E4%BB%A3%E7%A0%81/"/>
    
    
    <category term="java" scheme="leeblog.icu/tags/java/"/>
    
    <category term="x页代码" scheme="leeblog.icu/tags/x%E9%A1%B5%E4%BB%A3%E7%A0%81/"/>
    
    <category term="代码" scheme="leeblog.icu/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Java一页代码之——实现微信自动智能回复</title>
    <link href="leeblog.icu/2020/07/10/"/>
    <id>leeblog.icu/2020/07/10/</id>
    <published>2020-07-10T07:25:48.000Z</published>
    <updated>2022-05-23T07:31:33.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>机器可以替代我们自动打开空调，可以替代我们洗碗拖地，甚至替代我们开车(真开车，别多想)，<br>现在，它还可以替我们聊天，是的，它说：Yes，I do!</p></blockquote><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><h3 id="实现效果先看一眼："><a href="#实现效果先看一眼：" class="headerlink" title="实现效果先看一眼："></a>实现效果先看一眼：</h3><p>【这个enmm暂时还没有，因为没人给俺发消息】 </p><h3 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h3><ol><li>利用微信网页端接口登陆微信并监听消息</li><li>收到消息后请求图灵智能机器人api接口获得智能回复消息内容</li><li>通过微信接口回复智能消息</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li><p>maven引入包</p><ul><li>wechat-api (来自<a href="https://github.com/biezhi/wechat-api">biezhi的github</a>)<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.biezhi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>wechat-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><a href="https://hutool.cn/">HuTool</a> (一个小而美的java工具包)<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>一页代码（俺贴心的给你们设置了白名单机制，在哪儿设置自己找）</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lee.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.http.HttpRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONUtil;</span><br><span class="line"><span class="keyword">import</span> io.github.biezhi.wechat.WeChatBot;</span><br><span class="line"><span class="keyword">import</span> io.github.biezhi.wechat.api.annotation.Bind;</span><br><span class="line"><span class="keyword">import</span> io.github.biezhi.wechat.api.constant.Config;</span><br><span class="line"><span class="keyword">import</span> io.github.biezhi.wechat.api.enums.MsgType;</span><br><span class="line"><span class="keyword">import</span> io.github.biezhi.wechat.api.model.WeChatMessage;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloBot</span> <span class="keyword">extends</span> <span class="title">WeChatBot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloBot</span><span class="params">(Config config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; notRec=Arrays.asList(<span class="string">&quot;老聂&quot;</span>,<span class="string">&quot;老黄&quot;</span>);</span><br><span class="line">    <span class="meta">@Bind(msgType = MsgType.TEXT)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleText</span><span class="params">(WeChatMessage message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(message.getName())</span><br><span class="line">                &amp;&amp;!message.isGroup()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到 [&quot;</span>+message.getName()+<span class="string">&quot;] 的消息: &quot;</span></span><br><span class="line">                                                  +message.getText());</span><br><span class="line">             String mSg =<span class="string">&quot;我可能有点问题,等会回复你噢&quot;</span>;</span><br><span class="line">             <span class="keyword">if</span>(!notRec.contains(message.getFromRemarkName())) &#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     mSg = getReply(message.getText());</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                     System.out.println(e.getMessage());</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">this</span>.sendMsg(message.getFromUserName(), mSg );</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">String <span class="title">getReply</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String param=<span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    \&quot;perception\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        \&quot;inputText\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;            \&quot;text\&quot;: \&quot;MSG\&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        &#125;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    &#125;,\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    \&quot;userInfo\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        \&quot;apiKey\&quot;: \&quot;608df9e00ab648ac91968a20b11dba3f\&quot;,\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        \&quot;userId\&quot;: \&quot;635279\&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    &#125;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String body = HttpRequest.post(<span class="string">&quot;https://openapi.tuling123.com/openapi/api/v2&quot;</span>)</span><br><span class="line">                .body(JSONUtil.parse(param.replace(<span class="string">&quot;MSG&quot;</span>,msg)).toString())</span><br><span class="line">                .execute().body();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> JSONUtil.parseObj(body).getByPath(<span class="string">&quot;results[0].values.text&quot;</span>).toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> HelloBot(Config.me().autoLogin(<span class="keyword">true</span>).showTerminal(<span class="keyword">true</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：里面图灵接口的请求参数apiKey及userId是俺在<a href="http://www.turingapi.com/">图灵API</a> 注册获取的，有需要可自己去注册。</p><h2 id="更多翻车栗子"><a href="#更多翻车栗子" class="headerlink" title="更多翻车栗子"></a>更多翻车栗子</h2><p><a href="https://www.pianshen.com/article/96801052825/">微信自动回复 | 如何智能秒回女朋友 - 程序员大本营</a></p></li></ul><p><strong>本文作者</strong>：Lee<br/><strong>本文地址</strong>： <a href="leeblog.icu/2020/07/10/">leeblog.icu/2020/07/10/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC 4.0 BY-NC-SA</a> 许可协议。转载请注明出处！</p>]]></content>
    
    
    <summary type="html">机器可以替代我们自动打开空调，可以替代我们洗碗拖地，甚至替代我们开车(真开车，别多想)，现在，它还可以替我们聊天，是的，它说：Yes，I do!</summary>
    
    
    
    <category term="技术" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="代码" scheme="leeblog.icu/categories/%E6%8A%80%E6%9C%AF/%E4%BB%A3%E7%A0%81/"/>
    
    
    <category term="java" scheme="leeblog.icu/tags/java/"/>
    
    <category term="x页代码" scheme="leeblog.icu/tags/x%E9%A1%B5%E4%BB%A3%E7%A0%81/"/>
    
    <category term="wechat" scheme="leeblog.icu/tags/wechat/"/>
    
    <category term="代码" scheme="leeblog.icu/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>北京的雪</title>
    <link href="leeblog.icu/2019/11/30/"/>
    <id>leeblog.icu/2019/11/30/</id>
    <published>2019-11-30T14:47:45.000Z</published>
    <updated>2022-05-23T03:38:47.197Z</updated>
    
    <content type="html"><![CDATA[<p>上午就听人说今天会下雪，于是便已经隐隐盼着了。</p><p>北京上一年一整个冬天都是没有雪的，只是凌冽而干燥的风直直的吹着，吹起了大兴的一场大火，吹走了这个城市无数漂泊的人。</p><p>下午四五点，便看到昌平、延庆的朋友发的动态，下雪了、下雪了。真让人艳羡，恨不能钻进屏幕、走进去、走进去。</p><p>然后便是听得身边的人陆陆续续的谣传，“嘿外面下了”，“哦下了么？”。然而是没有的，我一次次趴着窗户去看楼下一杵杵路灯，窗玻璃上被呼吸嘘满白气，似乎要硬生生的从眼里生出一片片雪花来。然而什么也没有。</p><p>我想起了我们的园艺师，那个一直披着黑色的长长的几乎垂地的风衣，穿梭在长长的走廊里照料这里花草的女人。我一直想她大概是个魔法师，或者是女巫，反正绝不只是一个园艺师，无论怎样，她都是一个神秘的人。</p><p>也许她能变出雪来。</p><p>下午六点，同事们陆陆续续下班了，回家看雪去了，“周一见”，“周一见！”。我想，没有雪，也没有女巫，大概西城是不会有雪了。</p><p>晚上八点，刚从游泳池哆哆嗦嗦爬出来，便听老马说外面下雪了。“下了！”，“下了？”，“下了！”，马爷是个老实人，他一直在这儿勤勤恳恳尽职尽责的照料泳池，我知道这次是真的下了。</p><p>于是急急忙忙的冲个澡，换衣服。看了眼窗外，不大，但真的下了。我那个号称防风防雨防霜防雪甚至防冰雹的、加长加厚加宽加大的羽绒服在此时有了用武之地。裹上衣服、叼上根烟，头发顾不上扎了，就那么披头散发的跑了出去。</p><p>下了,不仅下了，而且越下越大，天空毫不吝啬的撒下一簇簇雪花，整个街区洋溢着欢快的气氛，整个西城洋溢着欢快的气氛，整个北京洋溢着快乐。</p><p>有人在车上的雪面上画下日期，有人在路灯下迎着雪花紧紧相拥，有人醉了，有人醒着，有人在奔跑，有人在骑车，有人漫步于此、他的身后，跟着条同样年迈而淡定的狗。</p><p>此时京城，无关政治、无关苟且，也无关千秋大业万丈红尘，只有当下的雪月风花，只剩下美，只剩下爱。</p><p align="right">写于西城太仆寺街xx号</p> <p><strong>本文作者</strong>：Lee<br/><strong>本文地址</strong>： <a href="leeblog.icu/2019/11/30/">leeblog.icu/2019/11/30/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC 4.0 BY-NC-SA</a> 许可协议。转载请注明出处！</p>]]></content>
    
    
    <summary type="html">我想起了我们的园艺师，那个一直披着黑色的长长的几乎垂地的风衣，穿梭在长长的走廊里照料这里花草的女人</summary>
    
    
    
    <category term="随笔" scheme="leeblog.icu/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="leeblog.icu/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
